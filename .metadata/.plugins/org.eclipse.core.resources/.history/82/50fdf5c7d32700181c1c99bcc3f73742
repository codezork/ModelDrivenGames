/*
 * generated by Xtext 2.12.0
 */
package com.hypermodel.games.engine.generator

import com.badlogic.gdx.Gdx
import com.badlogic.gdx.graphics.GL20
import com.badlogic.gdx.graphics.Texture
import com.badlogic.gdx.graphics.g2d.SpriteBatch
import com.hypermodel.games.engine.gameDSL.GameModel
import com.hypermodel.games.engine.gameDSL.GamePackage
import com.hypermodel.games.engine.utils.ImportHelper
import java.io.ByteArrayInputStream
import java.io.File
import java.io.FileInputStream
import java.io.IOException
import java.io.StringWriter
import java.util.ArrayList
import java.util.Date
import java.util.Properties
import java.util.stream.Collectors
import javax.inject.Inject
import org.eclipse.core.internal.resources.ProjectDescription
import org.eclipse.core.resources.IContainer
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.FileLocator
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.core.runtime.Path
import org.eclipse.core.runtime.Platform
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.jdt.core.IClasspathEntry
import org.eclipse.jdt.core.JavaCore
import org.eclipse.jdt.launching.JavaRuntime
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.xbase.compiler.GeneratorConfig
import org.eclipse.xtext.xbase.compiler.IGeneratorConfigProvider
import org.eclipse.xtext.xbase.compiler.ImportManager
import org.osgi.framework.FrameworkUtil
import org.slf4j.LoggerFactory
import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GameDSLGenerator extends ExtendedJvmModelGenerator {
	@Inject IGeneratorConfigProvider generatorConfigProvider
	@Inject extension IQualifiedNameProvider
	@Inject extension ImportHelper
	
	private enum ProjectType {
		core,
		android,
		desktop,
		html,
		ios,
		iosmoe;
	} 
	
	val log = LoggerFactory.getLogger(GameDSLGenerator)
	var monitor = new NullProgressMonitor()
	
	override createAppendable(EObject context, ImportManager importManager, GeneratorConfig config) {
		super.builder = context.eResource
		addClasses(importManager, _typeReferenceBuilder
			, SpriteBatch
			, Texture
			, Gdx
			, GL20
			, AndroidApplicationConfiguration
		)
		super.createAppendable(context, importManager, config)
	}
	
	override doGenerate(Resource input, IFileSystemAccess fsa) {
		var model = input.contents.get(0) as GameModel
		var i = 1
		for(pckg:model.packages) {
			// get core module
			var type = input.contents.get(i++) as JvmDeclaredType
			var packageName = type.fullyQualifiedName.skipLast(1)
			for(game:pckg.games) {
				// delete projects first
				for(ProjectType pType: ProjectType.values()) {
					var sub = ResourcesPlugin.workspace.root.getProject(game.name+"-"+pType.name)
					if(sub.exists) {
						sub.delete(true, monitor)
					}
				}
				var project = ResourcesPlugin.workspace.root.getProject(game.name)
				if(project.exists()) {
					project.delete(true, monitor)
				}
				createProject(project)
				for(ProjectType pType: ProjectType.values()) {
					var sub = ResourcesPlugin.workspace.root.getProject(game.name+"-"+pType.name)
					createSubProject(sub, project, packageName, pType, pckg)
					generatePlatformSource(sub, packageName, game.name, pType, type)
			    }
			}
		}
	}
	
	def copyPlatformResources(IProject project, ProjectType pType) {
		var bundle = FrameworkUtil.getBundle(getClass())
		var path = bundle.getEntry('''resources/«pType.name»''');
		if(path !== null) {
			var srcFolder = new File(FileLocator.resolve(path).toURI());
			copyFiles(srcFolder, project as IContainer)
		}
	}
	
	def void copyFiles (File srcFolder, IContainer destFolder) {
	    for (File f: srcFolder.listFiles()) {
	        if (f.isDirectory()) {
	            var newFolder = destFolder.getFolder(new Path(f.getName()));
	            newFolder.create(true, true, monitor);
	            copyFiles(f, newFolder);
	        } else {
	            var newFile = destFolder.getFile(new Path(f.name));
	            newFile.create(new FileInputStream(f), true, monitor);
	        }
	    }
	}
	
	def createSubProject(IProject project, IProject rootProject, QualifiedName packageName, ProjectType pType, GamePackage pkg) {
		var array = <String>newArrayList
		array.add(JavaCore.NATURE_ID)
		array.add("org.eclipse.buildship.core.gradleprojectnature")
	    createBasicProject(project, rootProject, pType, array, false)
		createJDTProject(project, pType)

		copyPlatformResources(project, pType)

		var buildgradle = project.getFile("build.gradle")
		buildgradle.create(buildGradle(pType, packageName.toString, pkg), true, monitor)
		
		if(pType == ProjectType.android) {
			var androidManifest = project.getFile("AndroidManifest.xml")
			androidManifest.create(buildAndroidManifest(packageName.toString, pkg), true, monitor)
			var androidProperties = project.getFile("project.properties")
			androidProperties.create(buildAndroidProperties(pkg.config.android.apiLevel), true, monitor)
		} 
		return project
	}
	
	protected def IProject createProject(IProject project) {
		var array = <String>newArrayList
		array.add("org.eclipse.buildship.core.gradleprojectnature")
	    createBasicProject(project, null, null, array, true)

		// gradle
		var dotGradle = project.getFolder(".gradle");
		dotGradle.create(true, true, monitor);
		
		var gradleVersion = dotGradle.getFolder("2.14.1");
		gradleVersion.create(true, true, monitor)
		
		var taskArtifacts = gradleVersion.getFolder("taskArtifacts")
		taskArtifacts.create(true, true, monitor)

		var gitignore = project.getFile(".gitignore")
		gitignore.create(buildGitignore(), true, monitor)
		
		var buildgradle = project.getFile("build.gradle")
		buildgradle.create(buildGradleRoot(project.name), true, monitor)

		var gradleprops = project.getFile("gradle.properties")
		gradleprops.create(buildGradleProps(), true, monitor)

		var localprops = project.getFile("local.properties")
		localprops.create(buildLocalProps(), true, monitor)

		var settingsGradle = project.getFile("settings.gradle") 
		settingsGradle.create(buildSettingsGradle(), true, monitor)

		var gradle = project.getFolder("gradle");
		gradle.create(true, true, monitor);
		var wrapper = gradle.getFolder("wrapper");
		wrapper.create(true, true, monitor);
		var gradleWrapperJar = wrapper.getFile("gradle-wrapper.jar") 

		var File file = null		
		var FileInputStream wrapperStream = null
		var bundle = FrameworkUtil.getBundle(getClass())
		var fileURL = bundle.getEntry("resources/gradlewrapper/gradle-wrapper.jar");
		try {
    		file = new File(FileLocator.resolve(fileURL).toURI());
			wrapperStream = new FileInputStream(file)
			gradleWrapperJar.create(new FileInputStream(file), true, monitor)
		} catch (IOException e) {
			log.error("{}", e)
		} finally {
			try {
				if (wrapperStream !== null)
					wrapperStream.close();
			} catch (IOException ex) {
				log.error("{}", ex)
			}
		}
		
		var gradleWrapperProps = wrapper.getFile("gradle-wrapper.properties") 
		gradleWrapperProps.create(buildGradleWrapperProps(), true, monitor);

		var path = bundle.getEntry('''resources/root''');
		if(path !== null) {
			var srcFolder = new File(FileLocator.resolve(path).toURI());
			copyFiles(srcFolder, project as IContainer)
		}

		return project
	}

	def generatePlatformSource(IProject project, QualifiedName packageName, String coreSourceName, ProjectType pType, JvmDeclaredType type) {
		var fileName = ""
		var body = ""
		var extraSegment = ""
		switch(pType) {
			case core: {
				fileName = coreSourceName + '.java'
				body = type.generateType(generatorConfigProvider.get(type)).toString
			}
			case android: {
				fileName = "AndroidLauncher.java"
				body =
				'''
				package «packageName»;
				
				import android.os.Bundle;
				
				import com.badlogic.gdx.backends.android.AndroidApplication;
				import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration;
				import «packageName».«coreSourceName»;
				
				public class AndroidLauncher extends AndroidApplication {
					@Override
					protected void onCreate (Bundle savedInstanceState) {
						super.onCreate(savedInstanceState);
						AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
						initialize(new «coreSourceName»(), config);
					}
				}'''
			}
			case desktop: {
				fileName = "DesktopLauncher.java"
				extraSegment = ProjectType.desktop.name;
				body = 
				'''
				package «packageName».«ProjectType.desktop.name»;
				
				import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
				import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;
				import «packageName».«coreSourceName»;
				
				public class DesktopLauncher {
					public static void main (String[] arg) {
						LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
						new LwjglApplication(new «coreSourceName»(), config);
					}
				}'''
			}
			case html: {
				fileName = "HtmlLauncher.java"
				extraSegment = "client";
				body = 
				'''
				package «packageName».client;
				
				import com.badlogic.gdx.ApplicationListener;
				import com.badlogic.gdx.backends.gwt.GwtApplication;
				import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration;
				import «packageName».«coreSourceName»;
				
				public class HtmlLauncher extends GwtApplication {
				
				        // USE THIS CODE FOR A FIXED SIZE APPLICATION
				        @Override
				        public GwtApplicationConfiguration getConfig () {
				                return new GwtApplicationConfiguration(480, 320);
				        }
				        // END CODE FOR FIXED SIZE APPLICATION
				
				        // UNCOMMENT THIS CODE FOR A RESIZABLE APPLICATION
				        // PADDING is to avoid scrolling in iframes, set to 20 if you have problems
				        // private static final int PADDING = 0;
				        // private GwtApplicationConfiguration cfg;
				        //
				        // @Override
				        // public GwtApplicationConfiguration getConfig() {
				        //     int w = Window.getClientWidth() - PADDING;
				        //     int h = Window.getClientHeight() - PADDING;
				        //     cfg = new GwtApplicationConfiguration(w, h);
				        //     Window.enableScrolling(false);
				        //     Window.setMargin("0");
				        //     Window.addResizeHandler(new ResizeListener());
				        //     cfg.preferFlash = false;
				        //     return cfg;
				        // }
				        //
				        // class ResizeListener implements ResizeHandler {
				        //     @Override
				        //     public void onResize(ResizeEvent event) {
				        //         int width = event.getWidth() - PADDING;
				        //         int height = event.getHeight() - PADDING;
				        //         getRootPanel().setWidth("" + width + "px");
				        //         getRootPanel().setHeight("" + height + "px");
				        //         getApplicationListener().resize(width, height);
				        //         Gdx.graphics.setWindowedMode(width, height);
				        //     }
				        // }
				        // END OF CODE FOR RESIZABLE APPLICATION
				
				        @Override
				        public ApplicationListener createApplicationListener () {
				                return new «coreSourceName»();
				        }
				    }'''
			}
			case ios: {
				fileName = "IOSLauncher.java"
				extraSegment = "client";
				body = 
				'''
				package «packageName».client;
				
				import org.robovm.apple.foundation.NSAutoreleasePool;
				import org.robovm.apple.uikit.UIApplication;
				
				import com.badlogic.gdx.backends.iosrobovm.IOSApplication;
				import com.badlogic.gdx.backends.iosrobovm.IOSApplicationConfiguration;
				import «packageName».«coreSourceName»;
				
				public class IOSLauncher extends IOSApplication.Delegate {
				    @Override
				    protected IOSApplication createApplication() {
				        IOSApplicationConfiguration config = new IOSApplicationConfiguration();
				        return new IOSApplication(new «coreSourceName»(), config);
				    }
				
				    public static void main(String[] argv) {
				        NSAutoreleasePool pool = new NSAutoreleasePool();
				        UIApplication.main(argv, null, IOSLauncher.class);
				        pool.close();
				    }
				}'''
			}
			case iosmoe: {
				fileName = "IOSMoeLauncher.java"
				body = 
				'''
				package «packageName»;
				
				import com.badlogic.gdx.backends.iosmoe.IOSApplication;
				import com.badlogic.gdx.backends.iosmoe.IOSApplicationConfiguration;
				import org.moe.natj.general.Pointer;
				import «packageName».«coreSourceName»;
				
				import apple.uikit.c.UIKit;
				
				public class IOSMoeLauncher extends IOSApplication.Delegate {
				
				    protected IOSMoeLauncher(Pointer peer) {
				        super(peer);
				    }
				
				    @Override
				    protected IOSApplication createApplication() {
				        IOSApplicationConfiguration config = new IOSApplicationConfiguration();
				        config.useAccelerometer = false;
				        return new IOSApplication(new «coreSourceName»(), config);
				    }
				
				    public static void main(String[] argv) {
				        UIKit.UIApplicationMain(0, null, null, IOSMoeLauncher.class.getName());
				    }
				}'''
			}
		}
		
		var folder = project.getFolder("src")
		for(segment:packageName.segments) {
			folder = folder.getFolder(segment)
			if(!folder.exists) {
				folder.create(true, true, monitor);
			}
		}
		if(!extraSegment.empty) {
			folder = folder.getFolder(extraSegment)
			if(!folder.exists) {
				folder.create(true, true, monitor);
			}
		}
		var source = folder.getFile(fileName);
		if(source.exists) {
			source.delete(true, monitor)
		}
		source.create(new ByteArrayInputStream(body.getBytes("UTF-8")), true, monitor)
	}

	protected def void createBasicProject(IProject project, IProject rootProject, ProjectType pType, ArrayList<String> natures, boolean isRoot) {
		if(!isRoot) {
			var description = new ProjectDescription()
			description.name = rootProject.name+"-"+pType.name
			description.location = rootProject.getFolder(pType.name).location
			description.comment = "Project "+description.name+" created by hypermodels.com"
			description.natureIds = natures
			project.create(description, monitor)
		    project.open(monitor)
		} else {
			project.create(monitor)
		    project.open(monitor)
			var description = project.getDescription()
			description.comment = "Project "+description.name+" created by hypermodels.com"
			description.natureIds = natures
			project.setDescription(description, monitor)
		}
		// Configure the project to be a Java project and a gradle project
		var settings = project.getFolder(".settings");
		settings.create(true, true, monitor);
		
		var prefs = settings.getFile("org.eclipse.buildship.core.prefs")
		prefs.create(buildBuildship(isRoot), true, monitor)
	}
	
	protected def void createJDTProject(IProject project, ProjectType pType) {
		var entries = <IClasspathEntry>newArrayList
		var javaProject = JavaCore.create(project)
		// src
		var src = project.getFolder("src");
		src.create(true, true, monitor);
		var packageRoot = javaProject.getPackageFragmentRoot(src)
		var srcEntry = JavaCore.newSourceEntry(packageRoot.getPath(), null, null, null)
		entries.add(srcEntry)
		// gen
		if(pType == ProjectType.android) {
			var gen = project.getFolder("gen");
			gen.create(true, true, monitor);
			var packageRoot2 = javaProject.getPackageFragmentRoot(gen)
			var genEntry = JavaCore.newSourceEntry(packageRoot2.getPath(), null, null, null)
			entries.add(genEntry)
		}
		
		// Let's add JavaSE-1.6 to our classpath
		var executionEnvironmentsManager = JavaRuntime.getExecutionEnvironmentsManager();
		var executionEnvironments = executionEnvironmentsManager.getExecutionEnvironments();
		for (iExecutionEnvironment : executionEnvironments) {
		    // We will look for JavaSE-1.6 as the JRE container to add to our classpath
		    if ("JavaSE-1.6".equals(iExecutionEnvironment.getId())) {
		        entries.add(JavaCore.newContainerEntry(JavaRuntime.newJREContainerPath(iExecutionEnvironment)));
		    }
		}

		var gradleEntry = JavaCore.newContainerEntry(new Path("org.eclipse.buildship.core.gradleclasspathcontainer"), true)
		entries.add(gradleEntry)

		if(pType == ProjectType.android) {
			var android1 = JavaCore.newContainerEntry(new Path("com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"), true)
			entries.add(android1)
			var android2 = JavaCore.newContainerEntry(new Path("com.android.ide.eclipse.adt.LIBRARIES"), true)
			entries.add(android2)
			var android3 = JavaCore.newContainerEntry(new Path("com.android.ide.eclipse.adt.DEPENDENCIES"), true)
			entries.add(android3)
		}
		javaProject.setRawClasspath(entries, null)

		// Let's create our target/classes output folder
		var binFolder = project.getFolder("bin");
		binFolder.create(true, true, monitor);
		if(pType == ProjectType.android) {
			var classesFolder = binFolder.getFolder("classes");
			classesFolder.create(true, true, monitor);
			javaProject.setOutputLocation(classesFolder.getFullPath(), null);
		} else {
			javaProject.setOutputLocation(binFolder.getFullPath(), null);
		}
		
		var settings = project.getFolder(".settings");
		var prefs = settings.getFile("org.eclipse.jdt.core.prefs")
		prefs.create(buildJDT(), true, monitor)
	}
	
	def ByteArrayInputStream buildGradleWrapperProps() {
		var prop = new Properties()
		prop.setProperty("distributionBase","GRADLE_USER_HOME")
		prop.setProperty("distributionPath","wrapper/dists")
		prop.setProperty("zipStoreBase","GRADLE_USER_HOME")
		prop.setProperty("zipStorePath","wrapper/dists")
		prop.setProperty("distributionUrl","https://services.gradle.org/distributions/gradle-2.14.1-bin.zip")
		var writer = new StringWriter()
		prop.store(writer, null)
		return new ByteArrayInputStream(writer.toString.getBytes("UTF-8"))
	}
	
	def ByteArrayInputStream buildSettingsGradle() {
		var projects = ProjectType.values.stream.map[v|"':"+v.name+"'"].collect(Collectors.joining(", "))		
		return new ByteArrayInputStream(("include "+projects).getBytes("UTF-8"))
	}
	
	def ByteArrayInputStream buildLocalProps() {
		// get the android sdk directory from prefs
		var dir = Platform.getPreferencesService().getString("com.android.ide.eclipse.adt", "com.android.ide.eclipse.adt.sdk", null, null);
		dir = dir.replace("\\", "/")
		return new ByteArrayInputStream(("sdk.dir="+dir).getBytes("UTF-8"))
	}

	def ByteArrayInputStream buildGradleProps() {
		var prop = new Properties()
		prop.setProperty("org.gradle.daemon","true")
		prop.setProperty("org.gradle.jvmargs","-Xms128m -Xmx1500m")
		prop.setProperty("org.gradle.configureondemand","true")
		var writer = new StringWriter()
		prop.store(writer, null)
		return new ByteArrayInputStream(writer.toString.getBytes("UTF-8"))
	}
	
	def ByteArrayInputStream buildGradleRoot(String projectName) {
		var script = 
		'''
		gradle.startParameter.showStacktrace = org.gradle.api.logging.configuration.ShowStacktrace.ALWAYS
		buildscript {
		    repositories {
		        mavenLocal()
		        mavenCentral()
		        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
		        jcenter()
		    }
		    dependencies {
		        classpath 'de.richsource.gradle.plugins:gwt-gradle-plugin:0.6'
		        classpath 'com.android.tools.build:gradle:2.2.0'
		        classpath 'com.mobidevelop.robovm:robovm-gradle-plugin:2.3.3'
		        classpath 'org.multi-os-engine:moe-gradle:1.4.0'
		    }
		}
		
		allprojects {
		    apply plugin: "eclipse"
		    apply plugin: "idea"
		
		    version = '1.0'
		    ext {
		        appName = "«projectName»"
		        gdxVersion = '1.9.8'
		        roboVMVersion = '2.3.3'
		        box2DLightsVersion = '1.4'
		        ashleyVersion = '1.7.0'
		        aiVersion = '1.8.0'
		    }
		
		    repositories {
		        mavenLocal()
		        mavenCentral()
		        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
		        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
		    }
		}
		
		project(":«ProjectType.desktop.name»") {
		    apply plugin: "java"
		
		
		    dependencies {
		        compile project(":«ProjectType.core.name»")
		        compile "com.badlogicgames.gdx:gdx-backend-lwjgl:$gdxVersion"
		        compile "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
		        compile "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-desktop"
		        
		    }
		}
		
		project(":«ProjectType.android.name»") {
		    apply plugin: "android"
		
		    configurations { natives }
		
		    dependencies {
		        compile project(":«ProjectType.core.name»")
		        compile "com.badlogicgames.gdx:gdx-backend-android:$gdxVersion"
		        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi"
		        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi-v7a"
		        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-arm64-v8a"
		        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-x86"
		        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-x86_64"
		        compile "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
		        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-armeabi"
		        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-armeabi-v7a"
		        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-arm64-v8a"
		        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-x86"
		        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-x86_64"
		    }
		}
		
		project(":«ProjectType.ios.name»") {
		    apply plugin: "java"
		    apply plugin: "robovm"
		
		
		    dependencies {
		        compile project(":«ProjectType.core.name»")
		        compile "com.mobidevelop.robovm:robovm-rt:$roboVMVersion"
		        compile "com.mobidevelop.robovm:robovm-cocoatouch:$roboVMVersion"
		        compile "com.badlogicgames.gdx:gdx-backend-robovm:$gdxVersion"
		        compile "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-ios"
		        compile "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-ios"
		    }
		}
		
		project(":«ProjectType.html.name»") {
		    apply plugin: "gwt"
		    apply plugin: "war"
		
		
		    dependencies {
		        compile project(":«ProjectType.core.name»")
		        compile "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion"
		        compile "com.badlogicgames.gdx:gdx:$gdxVersion:sources"
		        compile "com.badlogicgames.gdx:gdx-backend-gwt:$gdxVersion:sources"
		        compile "com.badlogicgames.gdx:gdx-box2d:$gdxVersion:sources"
		        compile "com.badlogicgames.gdx:gdx-box2d-gwt:$gdxVersion:sources"
		    }
		}
		
		project(":«ProjectType.core.name»") {
		    apply plugin: "java"
		
		
		    dependencies {
		        compile "com.badlogicgames.gdx:gdx:$gdxVersion"
		        compile "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
		    }
		}

		project(":iosmoe") {
		    apply plugin: "moe"
		
		    configurations { natives }
		
		    dependencies {
		        compile project(":core")
		        compile "com.badlogicgames.gdx:gdx-backend-moe:$gdxVersion"
		        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-ios"
		        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-ios"
		    }
		}
		
		tasks.eclipse.doLast {
		    delete ".project"
		}
		'''
		return new ByteArrayInputStream(script.getBytes("UTF-8"))
	}
	
	def ByteArrayInputStream buildGitignore() {
		var content = 
		'''
		## Java
		
		*.class
		*.war
		*.ear
		hs_err_pid*
		
		## Robovm
		/«ProjectType.ios.name»/robovm-build/
		
		## GWT
		/«ProjectType.html.name»/war/
		/«ProjectType.html.name»/gwt-unitCache/
		.apt_generated/
		.gwt/
		gwt-unitCache/
		www-test/
		.gwt-tmp/
		
		## Android Studio and Intellij and Android in general
		/android/libs/armeabi/
		/android/libs/armeabi-v7a/
		/android/libs/arm64-v8a/
		/android/libs/x86/
		/android/libs/x86_64/
		/android/gen/
		.idea/
		*.ipr
		*.iws
		*.iml
		/«ProjectType.android.name»/out/
		com_crashlytics_export_strings.xml
		
		## Eclipse
		
		.classpath
		.project
		.metadata/
		/«ProjectType.android.name»/bin/
		/«ProjectType.core.name»/bin/
		/«ProjectType.desktop.name»/bin/
		/«ProjectType.html.name»/bin/
		/«ProjectType.ios.name»/bin/
		/«ProjectType.iosmoe.name»/bin/
		*.tmp
		*.bak
		*.swp
		*~.nib
		.settings/
		.loadpath
		.externalToolBuilders/
		*.launch
		
		## NetBeans
		
		/nbproject/private/
		/«ProjectType.android.name»/nbproject/private/
		/«ProjectType.core.name»/nbproject/private/
		/«ProjectType.desktop.name»/nbproject/private/
		/«ProjectType.html.name»/nbproject/private/
		/«ProjectType.ios.name»/nbproject/private/
		/«ProjectType.iosmoe.name»/nbproject/private/
		
		/build/
		/«ProjectType.android.name»/build/
		/«ProjectType.core.name»/build/
		/«ProjectType.desktop.name»/build/
		/«ProjectType.html.name»/build/
		/«ProjectType.ios.name»/build/
		/«ProjectType.iosmoe.name»/build/
		
		/nbbuild/
		/«ProjectType.android.name»/nbbuild/
		/«ProjectType.core.name»/nbbuild/
		/«ProjectType.desktop.name»/nbbuild/
		/«ProjectType.html.name»/nbbuild/
		/«ProjectType.ios.name»/nbbuild/
		/«ProjectType.iosmoe.name»/nbbuild/
		
		/dist/
		/«ProjectType.android.name»/dist/
		/«ProjectType.core.name»/dist/
		/«ProjectType.desktop.name»/dist/
		/«ProjectType.html.name»/dist/
		/«ProjectType.ios.name»/dist/
		/«ProjectType.iosmoe.name»/dist/
		
		/nbdist/
		/«ProjectType.android.name»/nbdist/
		/«ProjectType.core.name»/nbdist/
		/«ProjectType.desktop.name»/nbdist/
		/«ProjectType.html.name»/nbdist/
		/«ProjectType.ios.name»/nbdist/
		/«ProjectType.iosmoe.name»/nbdist/
		
		nbactions.xml
		nb-configuration.xml
		
		## Gradle
		
		/local.properties
		.gradle/
		gradle-app.setting
		/build/
		/«ProjectType.android.name»/build/
		/«ProjectType.core.name»/build/
		/«ProjectType.desktop.name»/build/
		/«ProjectType.html.name»/build/
		/«ProjectType.ios.name»/build/
		/«ProjectType.iosmoe.name»/build/
		
		## OS Specific
		.DS_Store
		Thumbs.db
		
		## iOS
		/«ProjectType.ios.name»/xcode/*.xcodeproj/*
		!/«ProjectType.ios.name»/xcode/*.xcodeproj/xcshareddata
		!/«ProjectType.ios.name»/xcode/*.xcodeproj/project.pbxproj
		/«ProjectType.ios.name»/xcode/native/
		
		/«ProjectType.iosmoe.name»/xcode/*.xcodeproj/*
		!/«ProjectType.iosmoe.name»/xcode/*.xcodeproj/xcshareddata
		!/«ProjectType.iosmoe.name»/xcode/*.xcodeproj/project.pbxproj
		/«ProjectType.iosmoe.name»/xcode/native/
		'''
		return new ByteArrayInputStream(content.getBytes("UTF-8"))
	}
	
	protected def ByteArrayInputStream buildBuildship(boolean isRoot) {
		var today = new Date();
		var content = new StringBuilder()
		content.append("#")
		content.append(today.toString)
		content.append("\n")
		if(isRoot) {
			content.append("connection.project.dir=\n")
		} else {
			content.append("connection.project.dir=..\n")
		}
		return new ByteArrayInputStream(content.toString.getBytes("UTF-8"))	
	}
	
	protected def buildJDT() {
		var prop = new Properties()
		prop.setProperty("eclipse.preferences.version","1")
		prop.setProperty("org.eclipse.jdt.core.compiler.codegen.targetPlatform","1.6")
		prop.setProperty("org.eclipse.jdt.core.compiler.compliance","1.6")
		prop.setProperty("org.eclipse.jdt.core.compiler.source","1.6")
		var writer = new StringWriter()
		prop.store(writer, null)
		return new ByteArrayInputStream(writer.toString.getBytes("UTF-8"))
	}

	protected def buildAndroidProperties(int apiLevel) {
		var script = 
		'''
		# This file is used by the Eclipse ADT plugin. It is unnecessary for IDEA and Android Studio projects, which
		# configure Proguard and the Android target via the build.gradle file.
		
		# To enable ProGuard to work with Eclipse ADT, uncomment this (available properties: sdk.dir, user.home)
		# and ensure proguard.jar in the Android SDK is up to date (or alternately reduce the android target to 23 or lower):
		# proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-rules.pro
		
		# Project target.
		target=android-«apiLevel»
		'''
		return new ByteArrayInputStream(script.getBytes("UTF-8"))
	}
	
	protected def buildGradle(ProjectType pType, String packageName, GamePackage pkg) {
		var script = ""
		switch(pType) {
			case core: {
				script = 
				'''
				apply plugin: "java"
				
				sourceCompatibility = 1.6
				[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
				
				sourceSets.main.java.srcDirs = [ "src/" ]
				
				
				eclipse.project {
				    name = appName + "-«pType.name»"
				}'''
			}
			case android: {
//				var dir = Platform.getPreferencesService().getString("com.android.ide.eclipse.adt", "com.android.ide.eclipse.adt.sdk", null, null);
//				var prefs = InstanceScope.INSTANCE.getNode("com.android.ide.eclipse.adt");
				script = 
				'''	
				«ProjectType.android.name» {
				    buildToolsVersion "25.0.3"
				    compileSdkVersion 25
				    sourceSets {
				        main {
				            manifest.srcFile 'AndroidManifest.xml'
				            java.srcDirs = ['src']
				            aidl.srcDirs = ['src']
				            renderscript.srcDirs = ['src']
				            res.srcDirs = ['res']
				            assets.srcDirs = ['assets']
				            jniLibs.srcDirs = ['libs']
				        }
				
				        instrumentTest.setRoot('tests')
				    }
				    packagingOptions {
				        exclude 'META-INF/robovm/ios/robovm.xml'
				    }
				    defaultConfig {
				        applicationId "«packageName»"
				        minSdkVersion «pkg.config.android.minAndroidVersion»
				        targetSdkVersion «pkg.config.android.targetAndroidVersion»
				        versionCode 1
				        versionName "1.0"
				    }
				    buildTypes {
				        release {
				            minifyEnabled false
				            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
				        }
				    }
				}
				
				
				// called every time gradle gets executed, takes the native dependencies of
				// the natives configuration, and extracts them to the proper libs/ folders
				// so they get packed with the APK.
				task copyAndroidNatives() { 
				    file("libs/armeabi/").mkdirs();
				    file("libs/armeabi-v7a/").mkdirs();
				    file("libs/arm64-v8a/").mkdirs();
				    file("libs/x86_64/").mkdirs();
				    file("libs/x86/").mkdirs();
				
				    configurations.natives.files.each { jar ->
				        def outputDir = null
				        if(jar.name.endsWith("natives-arm64-v8a.jar")) outputDir = file("libs/arm64-v8a")
				        if(jar.name.endsWith("natives-armeabi-v7a.jar")) outputDir = file("libs/armeabi-v7a")        
				        if(jar.name.endsWith("natives-armeabi.jar")) outputDir = file("libs/armeabi")
				        if(jar.name.endsWith("natives-x86_64.jar")) outputDir = file("libs/x86_64")
				        if(jar.name.endsWith("natives-x86.jar")) outputDir = file("libs/x86")
				        if(outputDir != null) {
				            copy {
				                from zipTree(jar)
				                into outputDir
				                include "*.so"
				            }
				        }
				    }
				}
				
				task run(type: Exec) {
				    def path
				    def localProperties = project.file("../local.properties")
				    if (localProperties.exists()) {
				        Properties properties = new Properties()
				        localProperties.withInputStream { instr ->
				            properties.load(instr)
				        }
				        def sdkDir = properties.getProperty('sdk.dir')
				        if (sdkDir) {
				            path = sdkDir
				        } else {
				            path = "$System.env.ANDROID_HOME"
				        }
				    } else {
				        path = "$System.env.ANDROID_HOME"
				    }
				
				    def adb = path + "/platform-tools/adb"
				    commandLine "$adb", 'shell', 'am', 'start', '-n', '«packageName»/«packageName».AndroidLauncher'
				}
				
				// sets up the Android Eclipse project, using the old Ant based build.
				eclipse {
				    // need to specify Java source sets explicitly, SpringSource Gradle Eclipse plugin
				    // ignores any nodes added in classpath.file.withXml
				    sourceSets {
				        main {
				            java.srcDirs "src", 'gen'
				        }
				    }
				
				    jdt {
				        sourceCompatibility = 1.6
				        targetCompatibility = 1.6
				    }
				
				    classpath {
				        plusConfigurations += [ project.configurations.compile ]        
				        containers 'com.android.ide.eclipse.adt.ANDROID_FRAMEWORK', 'com.android.ide.eclipse.adt.LIBRARIES'       
				    }
				
				    project {
				        name = appName + "-«ProjectType.android.name»"
				        natures 'com.android.ide.eclipse.adt.AndroidNature'
				        buildCommands.clear();
				        buildCommand "com.android.ide.eclipse.adt.ResourceManagerBuilder"
				        buildCommand "com.android.ide.eclipse.adt.PreCompilerBuilder"
				        buildCommand "org.eclipse.jdt.core.javabuilder"
				        buildCommand "com.android.ide.eclipse.adt.ApkBuilder"
				    }
				}
				
				// sets up the Android Idea project, using the old Ant based build.
				idea {
				    module {
				        sourceDirs += file("src");
				        scopes = [ COMPILE: [plus:[project.configurations.compile]]]        
				
				        iml {
				            withXml {
				                def node = it.asNode()
				                def builder = NodeBuilder.newInstance();
				                builder.current = node;
				                builder.component(name: "FacetManager") {
				                    facet(type: "«pType.name»", name: "«pType.name.toFirstUpper»") {
				                        configuration {
				                            option(name: "UPDATE_PROPERTY_FILES", value:"true")
				                        }
				                    }
				                }
				            }
				        }
				    }
				}'''
			}
			case desktop: {
				script = 
				'''
				apply plugin: "java"
				
				sourceCompatibility = 1.6
				sourceSets.main.java.srcDirs = [ "src/" ]
				
				project.ext.mainClassName = "«packageName».«pType.name».DesktopLauncher"
				project.ext.assetsDir = new File("../«ProjectType.android.name»/assets");
				
				task run(dependsOn: classes, type: JavaExec) {
				    main = project.mainClassName
				    classpath = sourceSets.main.runtimeClasspath
				    standardInput = System.in
				    workingDir = project.assetsDir
				    ignoreExitValue = true
				}
				
				task debug(dependsOn: classes, type: JavaExec) {
				    main = project.mainClassName
				    classpath = sourceSets.main.runtimeClasspath
				    standardInput = System.in
				    workingDir = project.assetsDir
				    ignoreExitValue = true
				    debug = true
				}
				
				task dist(type: Jar) {
				    from files(sourceSets.main.output.classesDir)
				    from files(sourceSets.main.output.resourcesDir)
				    from {configurations.compile.collect {zipTree(it)}}
				    from files(project.assetsDir);
				 
				    manifest {
				        attributes 'Main-Class': project.mainClassName
				    }
				}
				
				dist.dependsOn classes
				
				eclipse {
				    project {
				        name = appName + "-«ProjectType.desktop.name»"
				        linkedResource name: 'assets', type: '2', location: 'PARENT-1-PROJECT_LOC/«ProjectType.android.name»/assets'
				    }
				}
				
				task afterEclipseImport(description: "Post processing after project generation", group: "IDE") {
				  doLast {
				    def classpath = new XmlParser().parse(file(".classpath"))
				    new Node(classpath, "classpathentry", [ kind: 'src', path: 'assets' ]);
				    def writer = new FileWriter(file(".classpath"))
				    def printer = new XmlNodePrinter(new PrintWriter(writer))
				    printer.setPreserveWhitespace(true)
				    printer.print(classpath)
				  }
				}'''
			}
			case html: {
				script = 
				'''
				apply plugin: "java"
				apply plugin: "jetty"
				
				gwt {
				    gwtVersion='2.8.0' // Should match the gwt version used for building the gwt backend
				    maxHeapSize="1G" // Default 256m is not enough for gwt compiler. GWT is HUNGRY
				    minHeapSize="1G"
				
				    src = files(file("src/")) // Needs to be in front of "modules" below.
				    modules '«packageName».GdxDefinition'
				    devModules '«packageName».GdxDefinitionSuperdev'
				    project.webAppDirName = 'webapp'
				
				    compiler {
				        strict = true;
				        disableCastChecking = true;
				    }
				}
				
				task draftRun(type: JettyRunWar) {
				    dependsOn draftWar
				    dependsOn.remove('war')
				    webApp=draftWar.archivePath
				    daemon=true
				}
				
				task superDev(type: de.richsource.gradle.plugins.gwt.GwtSuperDev) {
				    dependsOn draftRun
				    doFirst {
				    	gwt.modules = gwt.devModules
				    }
				}
				
				task dist(dependsOn: [clean, compileGwt]) {
				    doLast {
				        file("build/dist").mkdirs()
				        copy {
				            from "build/gwt/out"
				            into "build/dist"
				        }
				        copy {
				            from "webapp"
				            into "build/dist"
				            }
				        copy {
				            from "war"
				            into "build/dist"
				        }
				    }
				}
				
				draftWar {
				   from "war"
				}
				
				task addSource {
				    doLast {
				        sourceSets.main.compileClasspath += files(project(':«ProjectType.core.name»').sourceSets.main.allJava.srcDirs)
				    }
				}
				
				tasks.compileGwt.dependsOn(addSource)
				tasks.draftCompileGwt.dependsOn(addSource)
				
				sourceCompatibility = 1.6
				sourceSets.main.java.srcDirs = [ "src/" ]
				
				
				eclipse.project {
				    name = appName + "-«pType.name»"
				}''' 
			}
			case ios: {
				script = 
				'''
				sourceSets.main.java.srcDirs = [ "src/" ]
				
				sourceCompatibility = '1.7'
				[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
				
				ext {
					mainClassName = "«packageName».IOSLauncher"
				}
				
				launchIPhoneSimulator.dependsOn build
				launchIPadSimulator.dependsOn build
				launchIOSDevice.dependsOn build
				createIPA.dependsOn build
				
				robovm {
					archs = "thumbv7:arm64"
				}
				
				eclipse.project {
				    name = appName + "-«pType.name»"
				    natures 'org.robovm.eclipse.RoboVMNature'
				}''' 
			}
			case iosmoe: {
				script = 
				'''
				// Exclude all files from Gradle's test runner
				test { exclude '**' }
				
				task copyNatives {
				    doLast {
				        file("xcode/native/ios/").mkdirs();
				        def LD_FLAGS = "LIBGDX_NATIVES = "
				        configurations.natives.files.each { jar->
				            def outputDir = null
				            if (jar.name.endsWith("natives-ios.jar")) outputDir = file("xcode/native/ios")
				            if (outputDir != null) {
				                FileCollection fileCollection = zipTree(jar)
				                for (File libFile : fileCollection) {
				                    if (libFile.getAbsolutePath().endsWith(".a") && !libFile.getAbsolutePath().contains("/tvos/")) {
				                        copy {
				                            from libFile.getAbsolutePath()
				                            into outputDir
				                        }
				                        LD_FLAGS += " -force_load \${SRCROOT}/native/ios/" + libFile.getName()
				                    }
				                }
				            }
				        }
				        def outFlags = file("xcode/«ProjectType.iosmoe.name»/custom.xcconfig");
				        outFlags.write LD_FLAGS
				
				        def proguard = file("proguard.append.cfg")
				        if (!proguard.exists()) {
				            proguard = new File("proguard.append.cfg")
				            proguard << "\n-keep class com.badlogic.** { *; }\n"
				            proguard << "-keep enum com.badlogic.** { *; }\n"
				        }
				    }
				}
				
				sourceSets.main.java.srcDirs = [ "src/" ]
				
				// Setup Multi-OS Engine
				moe {
				    xcode {
				        project 'xcode/«ProjectType.iosmoe.name».xcodeproj'
				        mainTarget '«ProjectType.iosmoe.name»'
				        testTarget '«ProjectType.iosmoe.name»-Test'
				    }
				
				    remoteBuild {
				        resources = [ file("../android/assets") ]
				    }
				}
				
				moeMainReleaseIphoneosXcodeBuild.dependsOn copyNatives
				moeMainDebugIphoneosXcodeBuild.dependsOn copyNatives
				moeMainReleaseIphonesimulatorXcodeBuild.dependsOn copyNatives
				moeMainDebugIphonesimulatorXcodeBuild.dependsOn copyNatives
				
				// Setup Eclipse
				eclipse {
				    // Set Multi-OS Engine nature
				    project {
				        name = appName + "-«ProjectType.iosmoe.name»"
				        natures 'org.multi-os-engine.project'
				    }
				}
				'''
			}
		}
		return new ByteArrayInputStream(script.getBytes("UTF-8"))
	}

	protected def buildAndroidManifest(String packageName, GamePackage pkg) {
		var script = 
		'''
		<?xml version="1.0" encoding="utf-8"?>
		<manifest xmlns:android="http://schemas.android.com/apk/res/android"
		    package="«packageName»" >
		
		    <uses-sdk android:minSdkVersion="«pkg.config.android.minAndroidVersion»" android:targetSdkVersion="«pkg.config.android.targetAndroidVersion»" />
		
		    <application
		        android:allowBackup="true"
		        android:icon="@drawable/ic_launcher"
		        android:label="@string/app_name"
		        android:theme="@style/GdxTheme" >
		        <activity
		            android:name="«packageName».AndroidLauncher"
		            android:label="@string/app_name" 
		            android:screenOrientation="«pkg.config.android.orientation.literal»"
		            android:configChanges="keyboard|keyboardHidden|navigation|orientation|screenSize">
		            <intent-filter>
		                <action android:name="android.intent.action.MAIN" />
		                <category android:name="android.intent.category.LAUNCHER" />
		            </intent-filter>
		        </activity>
		    </application>
		
		</manifest>
		'''
		return new ByteArrayInputStream(script.getBytes("UTF-8"))
	}
}
