package com.hypermodel.games.engine.jvmmodel

import android.os.Bundle
import com.badlogic.gdx.ApplicationListener
import com.badlogic.gdx.Game
import com.badlogic.gdx.Screen
import com.badlogic.gdx.audio.Music
import com.badlogic.gdx.backends.android.AndroidApplication
import com.badlogic.gdx.backends.gwt.GwtApplication
import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration
import com.badlogic.gdx.backends.iosrobovm.IOSApplication
import com.badlogic.gdx.graphics.Color
import com.badlogic.gdx.graphics.OrthographicCamera
import com.badlogic.gdx.graphics.g2d.Animation
import com.badlogic.gdx.graphics.g2d.BitmapFont
import com.badlogic.gdx.graphics.g2d.Sprite
import com.badlogic.gdx.graphics.g2d.SpriteBatch
import com.badlogic.gdx.graphics.g2d.TextureAtlas
import com.badlogic.gdx.graphics.g2d.TextureRegion
import com.badlogic.gdx.maps.MapObject
import com.badlogic.gdx.maps.objects.RectangleMapObject
import com.badlogic.gdx.maps.tiled.TiledMap
import com.badlogic.gdx.maps.tiled.TiledMapTile
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer
import com.badlogic.gdx.maps.tiled.TmxMapLoader
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer
import com.badlogic.gdx.math.Rectangle
import com.badlogic.gdx.math.Vector2
import com.badlogic.gdx.physics.box2d.Body
import com.badlogic.gdx.physics.box2d.BodyDef
import com.badlogic.gdx.physics.box2d.Box2DDebugRenderer
import com.badlogic.gdx.physics.box2d.CircleShape
import com.badlogic.gdx.physics.box2d.Contact
import com.badlogic.gdx.physics.box2d.ContactImpulse
import com.badlogic.gdx.physics.box2d.ContactListener
import com.badlogic.gdx.physics.box2d.EdgeShape
import com.badlogic.gdx.physics.box2d.Filter
import com.badlogic.gdx.physics.box2d.Fixture
import com.badlogic.gdx.physics.box2d.FixtureDef
import com.badlogic.gdx.physics.box2d.Manifold
import com.badlogic.gdx.physics.box2d.PolygonShape
import com.badlogic.gdx.physics.box2d.World
import com.badlogic.gdx.scenes.scene2d.Stage
import com.badlogic.gdx.scenes.scene2d.ui.Label
import com.badlogic.gdx.scenes.scene2d.ui.Table
import com.badlogic.gdx.utils.Array
import com.badlogic.gdx.utils.Disposable
import com.badlogic.gdx.utils.viewport.FitViewport
import com.badlogic.gdx.utils.viewport.Viewport
import com.google.gwt.event.logical.shared.ResizeEvent
import com.google.gwt.event.logical.shared.ResizeHandler
import com.hypermodel.games.engine.gameDSL.GameActor
import com.hypermodel.games.engine.gameDSL.GameContactType
import com.hypermodel.games.engine.gameDSL.GameDisplayValueType
import com.hypermodel.games.engine.gameDSL.GamePackage
import com.hypermodel.games.engine.gameDSL.GameRoot
import com.hypermodel.games.engine.gameDSL.GameScene
import com.hypermodel.games.engine.gameDSL.GameScreen
import com.hypermodel.games.engine.gameDSL.GameSprite
import com.hypermodel.games.engine.gameDSL.GameTile
import com.hypermodel.games.engine.generator.GameProperties
import com.hypermodel.games.engine.generator.GameProperties.ProjectType
import javax.inject.Inject
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmField
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.compiler.output.ITreeAppendable
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.moe.natj.general.Pointer
import com.badlogic.gdx.Gdx
import com.badlogic.gdx.Input
import com.badlogic.gdx.graphics.GL20
import com.badlogic.gdx.graphics.g2d.Batch
import org.eclipse.xtext.common.types.TypesFactory
import org.eclipse.xtext.common.types.access.IJvmTypeProvider

class GameDSLJvmModelInferrer extends AbstractModelInferrer {
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	@Inject extension TypesFactory typesFactory
	@Inject extension IJvmTypeProvider.Factory typeProviderFactory
	
	val genInfo = "generated by hypermodels.com"

	def dispatch void infer(GamePackage gamePkg, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		gamePkg.games.forEach[game|
			// core module
			val rootClass = gamePkg.toClass(game.fullyQualifiedName) 
			acceptor.accept(
				rootClass,
				[
					superTypes += Game.typeRef
					packageName = game.fullyQualifiedName.skipLast(1).toString
					documentation = genInfo
					it.toFields(game)
					it.toOperations(gamePkg, game)
				]
			)
			// launchers
			ProjectType.values.filter[it != ProjectType.core].forEach[acceptor.createLauncher(gamePkg, game, it)]
			// scenes
			game.scenes.forEach[acceptor.createScene(gamePkg, rootClass, it)]
			// screens
			game.screens.forEach[acceptor.createScreen(gamePkg, rootClass, it, game)]
		]
	}

	protected def void createLauncher(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, GameRoot game, ProjectType pType) {
		val doc = genInfo
		switch (pType) {
			case ProjectType.android: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				launcherClass.superTypes.add(AndroidApplication.typeRef)
				acceptor.accept(
					launcherClass,
					[
						var method = game.toMethod("onCreate", Void.TYPE.typeRef, [
							parameters += game.toParameter("savedInstanceState", Bundle.typeRef)
							annotations += Override.annotationRef
							body = [
								append(
								'''
								super.onCreate(savedInstanceState);
								AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
								«IF gamePkg.config.android.useAccelerometer»config.useAccelerometer = true;«ENDIF»
								initialize(new «game.name.toFirstUpper»(), config);''')
							]
						])
						it.members += method
						packageName = gamePkg.fullyQualifiedName.toString
						documentation = doc
					]
				)
			}
			case ProjectType.desktop: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				acceptor.accept(
					launcherClass,
					[
						var method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
								new LwjglApplication(new «game.fullyQualifiedName»(), config);''')
							]
						])
						method.static = true
						it.members += method
						packageName = '''«gamePkg.fullyQualifiedName.toString».«pType.name»'''
						documentation = doc
					]
				)
			}
			case ProjectType.html: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				launcherClass.superTypes.add(GwtApplication.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = '''«gamePkg.fullyQualifiedName.toString».client'''
						documentation = doc
						var field = game.toField("PADDING", int.typeRef, [
							initializer = [append('''0''')]
						])
						it.members += field
						field = game.toField("cfg", GwtApplicationConfiguration.typeRef)
						it.members += field
						var method = game.toMethod("getConfig", GwtApplicationConfiguration.typeRef, [
								annotations += Override.annotationRef
								body = [
									append(
								'''
									int w = Window.getClientWidth() - PADDING;
									int h = Window.getClientHeight() - PADDING;
									cfg = new GwtApplicationConfiguration(w, h);
									Window.enableScrolling(false);
									Window.setMargin("0");
									Window.addResizeHandler(new ResizeListener());
									cfg.preferFlash = false;
									return cfg;''')
								]
							])
						it.members += method
						method = game.toMethod("createApplicationListener", ApplicationListener.typeRef, [
								annotations += Override.annotationRef
								body = [
									append(
								'''
									return new «game.fullyQualifiedName»();''')
								]
							])
						it.members += method
						val resizeClass = gamePkg.toClass("ResizeListener");
						resizeClass.superTypes.add(ResizeHandler.typeRef)
						var innermethod = game.toMethod("onResize", Void.TYPE.typeRef, [
							parameters += game.toParameter("event", ResizeEvent.typeRef)
							annotations += Override.annotationRef
							body = [
								append(
								'''
								int width = event.getWidth() - PADDING;
								int height = event.getHeight() - PADDING;
								getRootPanel().setWidth("" + width + "px");
								getRootPanel().setHeight("" + height + "px");
								getApplicationListener().resize(width, height);
								Gdx.graphics.setWindowedMode(width, height);''')
							]
						])
						resizeClass.members += innermethod
						it.members += resizeClass
					]
				)
			}
			case ProjectType.ios: {
				val launcherClass = gamePkg.toClass('''«pType.name.toUpperCase»Launcher''');
				launcherClass.superTypes.add(IOSApplication.Delegate.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = '''«gamePkg.fullyQualifiedName.toString»'''
						documentation = doc
						var method = game.toMethod("createApplication", IOSApplication.typeRef, [
							annotations += Override.annotationRef
							body = [
								append(
								'''
								IOSApplicationConfiguration config = new IOSApplicationConfiguration();
								«IF gamePkg.config.ios.useAccelerometer»config.useAccelerometer = true;«ENDIF»
								return new IOSApplication(new «game.name.toFirstUpper»(), config);''')
							]
						])
						it.members += method
						method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								NSAutoreleasePool pool = new NSAutoreleasePool();
								UIApplication.main(arg, null, «pType.name.toUpperCase»«GameProperties.launcherPostfix».class);
								pool.close();''')
							]
						])
						method.static = true
						it.members += method
					]
				)
			}
			case ProjectType.iosmoe: {
				val launcherClass = gamePkg.toClass('''«pType.name.toUpperCase»Launcher''');
				launcherClass.superTypes.add(com.badlogic.gdx.backends.iosmoe.IOSApplication.Delegate.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = gamePkg.fullyQualifiedName.toString
						documentation = doc
						var constructor = game.toConstructor( [
							parameters += game.toParameter("peer", Pointer.typeRef)
							body = [
								append(
								'''
								super(peer);''')
							]
						])
						constructor.visibility = JvmVisibility.PROTECTED
						it.members += constructor
						var method = game.toMethod("createApplication",	com.badlogic.gdx.backends.iosmoe.IOSApplication.typeRef, [
								annotations += Override.annotationRef
								body = [
									append(
								'''
									IOSApplicationConfiguration config = new IOSApplicationConfiguration();
									«IF gamePkg.config.iosmoe.useAccelerometer»config.useAccelerometer = true;«ENDIF»
									return new IOSApplication(new «game.name.toFirstUpper»(), config);''')
								]
							])
						it.members += method
						method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								UIKit.UIApplicationMain(0, null, null, «pType.name.toUpperCase»«GameProperties.launcherPostfix».class.getName());''')
							]
						])
						method.static = true
						it.members += method
					]
				)
			}
			default: {
			}
		}
	}

	def void toFields(JvmGenericType type, GameRoot game) {
		var JvmField field = null
		field = game.toField("batch", SpriteBatch.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("V_WIDTH", int.typeRef)[initializer = [append('''«game.width»''')]]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("V_HEIGHT", int.typeRef) [initializer = [append('''«game.height»''')]]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("TITLE", String.typeRef) [
			initializer = [append('''"«game.title»"''')]
		]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("PPM", float.typeRef)[initializer = [append('''«game.ppm»f''')]]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
	}

	def void toOperations(JvmGenericType type, GamePackage gamePkg, GameRoot game) {
		type.members += game.toMethod("create", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				it.append(
				'''
				batch = new SpriteBatch();
				''')
				for (screen : game.screens) {
					it.append("setScreen(new ")
					it.append(gamePkg.toClass(screen.fullyQualifiedName))
					it.append("(this));")
				}
			]
		])

		type.members += game.toMethod("render", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				super.render();''')
			]
		])
		type.members += game.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				super.dispose();
				batch.dispose();''')
			]
		])
	}

	// screens
	def void createScreen(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, GameScreen screen, GameRoot root) {
		// contactListener
		val contactClass = gamePkg.toClass(gamePkg.fullyQualifiedName+".WorldContact")
		acceptor.createContactListener(gamePkg, contactClass, root)
		
		val screenClass = gamePkg.toClass(screen.fullyQualifiedName) 

		// creator
		val creatorClass = gamePkg.toClass(gamePkg.fullyQualifiedName+".WorldCreator")
		acceptor.createCreator(gamePkg, creatorClass, gameClass, screenClass, screen, root)

		// player
		val playerSprite = screen.sprites.findFirst[it.hasStartPosition]
		var JvmGenericType pClass = null 
		if(playerSprite !== null) {
			pClass = gamePkg.toClass(playerSprite.fullyQualifiedName)
		}
		val playerClass = pClass
		acceptor.accept(
			screenClass,
			[
				superTypes += Screen.typeRef
				packageName = screen.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toFields(gamePkg, screen, gameClass, creatorClass, contactClass, playerClass)
				members += screen.toConstructor [
					parameters += gamePkg.toParameter("game", gameClass.typeRef)
					body = [
						append(
						'''
						this.game = game;
						atlas = new TextureAtlas("«screen.atlasName».pack");
						gamecam = new OrthographicCamera();
						gamePort = new ''')
						append(FitViewport)
						append(
						'''
						(«gameClass.simpleName».V_WIDTH / «gameClass.simpleName».PPM, «gameClass.simpleName».V_HEIGHT / «gameClass.simpleName».PPM, gamecam);
						mapLoader = new TmxMapLoader();
						map = mapLoader.load("«screen.map»");
						renderer = new OrthogonalTiledMapRenderer(map, 1 / «gameClass.simpleName».PPM);
						gamecam.position.set(gamePort.getWorldWidth() / 2, gamePort.getWorldHeight() / 2, 0);
						world = new World(new ''')
						append(Vector2)
						append(
						'''
						(0, -10), true);
						b2dr = new Box2DDebugRenderer();
						«IF screen.scene !== null»«screen.scene.name.toFirstLower» = new «screen.scene.name.toFirstUpper»(game.batch);«ENDIF»
						creator = new «creatorClass.fullyQualifiedName»(this);
						«IF playerClass !== null»player = new «playerClass.fullyQualifiedName»(this);«ENDIF»
						world.setContactListener(new «contactClass.fullyQualifiedName»());
						''')
						
					]
				]
				it.toOperations(screen, playerSprite, root)
			]
		)
		// sprites
		screen.sprites.forEach[acceptor.createSprite(gamePkg, gameClass, screenClass, it)]
		// tiles
		screen.tiles.forEach[acceptor.createTile(gamePkg, gameClass, screenClass, it, root)]
	}

	def void toFields(JvmGenericType type, GamePackage gamePkg, GameScreen screen, JvmGenericType gameClass, JvmGenericType creatorClass, JvmGenericType contactClass, JvmGenericType playerClass) {
		var JvmField field = null
		type.members += screen.toField("game", gameClass.typeRef)
		type.members += screen.toField("atlas", TextureAtlas.typeRef)
		type.members += screen.toField("gamecam", OrthographicCamera.typeRef);
		type.members += screen.toField("gamePort", Viewport.typeRef);
		type.members += screen.toField("mapLoader", TmxMapLoader.typeRef);
		type.members += screen.toField("map", TiledMap.typeRef);
		type.members += screen.toField("renderer", OrthogonalTiledMapRenderer.typeRef);
		type.members += screen.toField("world", World.typeRef);
		type.members += screen.toField("b2dr", Box2DDebugRenderer.typeRef);
		type.members += screen.toField("music", Music.typeRef);
		type.members += screen.toField("creator", creatorClass.typeRef);
		if(playerClass !== null) {
			type.members += screen.toField("player", playerClass.typeRef);
		}
//		type.members += screen.toField("items", Array, Item.typeRef)) ;
//		type.members += screen.toField("itemsToSpawn", LinkedBlockingQueue, ItemDef.typeRef)) ;
		if(screen.scene !== null) {
			field = screen.toField(screen.scene.name.toFirstLower, gamePkg.toClass(screen.scene.fullyQualifiedName).typeRef)
			field.visibility = JvmVisibility.PUBLIC 
			type.members += field
		}
	}

	def void toOperations(JvmGenericType type, GameScreen screen, GameSprite playerSprite, GameRoot game) {
		type.members += screen.toGetter("atlas", TextureAtlas.typeRef)
		type.members += screen.toGetter("map", TiledMap.typeRef)
		type.members += screen.toGetter("world", World.typeRef)
		type.members += screen.toMethod("resize", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			parameters += screen.toParameter("width", int.typeRef)
			parameters += screen.toParameter("height", int.typeRef)
			body = [
				append(
				'''
				gamePort.update(width, height);''')
			]
		])
		type.members += screen.toMethod("pause", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("resume", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				map.dispose();
				renderer.dispose();
				world.dispose();
				b2dr.dispose();
				«IF screen.scene !== null»«screen.scene.name.toFirstLower».dispose();«ENDIF»
				''')
			]
		])
		type.members += screen.toMethod("show", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("render", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			parameters += screen.toParameter("delta", float.typeRef)
			body = [
				if(!playerSprite.inputs.empty) {
			        val current = it
			        playerSprite.inputs.forEach[
			        	current.append('''if(''')
				        current.append(Gdx)
				        current.append('''.input.isKey«it.keyType.getName().toFirstUpper»(''')
				        current.append(Input)
				        current.append('''.Keys.«it.key.getName().toUpperCase»)) {
			        	''')
			        	current.append('''	player.«it.trigger.name»();
			        	''')
			        	current.append(
			        	'''}
			        	''')
			        ]
			    }
			    append(
			    '''
			    world.step(«game.timeStep»f, «game.velocityIterations», «game.positionIterations»);
			    player.update(delta);
			    creator.updateSprites(delta, player.getX());
			    hud.update(delta);
			    gamecam.position.x = player.body.getPosition().x;
			    gamecam.update();
			    renderer.setView(gamecam);
			    ''')
				append(Gdx)
				append(
				'''
				.gl.glClearColor(0, 0, 0, 1);
				Gdx.gl.glClear(''')
				append(GL20)
				append(
				'''
				.GL_COLOR_BUFFER_BIT);
				renderer.render();
				game.batch.setProjectionMatrix(gamecam.combined);
				game.batch.begin();
				player.draw(game.batch);
				creator.drawSprites(game.batch);
				game.batch.end();
				b2dr.render(world, gamecam.combined);
				game.batch.setProjectionMatrix(hud.stage.getCamera().combined);
				hud.stage.draw();
			    ''')
			]
		])
		type.members += screen.toMethod("hide", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
	}

	// scenes
	def void createScene(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, GameScene scene) {
		acceptor.accept(
			gamePkg.toClass(scene.fullyQualifiedName),
			[
				superTypes += Disposable.typeRef
				packageName = scene.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toFields(scene, gameClass)
				members += scene.toConstructor [
					parameters += gamePkg.toParameter("spriteBatch", SpriteBatch.typeRef)
					body = [
						append("viewport = new ")
						append(FitViewport)
						append("(")
						append(gamePkg.toClass(gameClass.fullyQualifiedName))
						append('''.V_WIDTH, «gameClass.simpleName».V_HEIGHT, new ''')
						append(OrthographicCamera)
						append("());\n")
						append("stage = new ")
						append(Stage)
						append("(viewport, spriteBatch);\n")
						append(Table)
						append(
						'''
						 table = new Table();
						table.top();
						table.setFillParent(true);
						stage.addActor(table);
						''')
						val current = it
						if(scene.hasScore) {
							scene.score.displays.forEach[
								current.append(
								'''
								«it.name»TitleLabel = new Label("«it.name.toUpperCase»", new Label.LabelStyle(new ''')
								current.append(BitmapFont)
								current.append("(), ")
								current.append(Color)
								current.append(".WHITE));\n")
								current.append(
								'''
								table.add(«it.name»TitleLabel).expandX().padTop(«scene.score.topPadding»);
								''')
							]
							it.append("table.row();\n")
							scene.score.displays.forEach[
								current.append(
								'''
								«it.name»ValueLabel = new Label(String.format("«it.format»", «it.name»), new Label.LabelStyle(new BitmapFont(), Color.WHITE));
								table.add(«it.name»ValueLabel).expandX();
								''')
							]
						}
					]
				]
				it.toOperations(scene)
			]
		)
	}

	def void toFields(JvmGenericType type, GameScene scene, JvmGenericType gameClass) {
		var field = scene.toField("stage", Stage.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		type.members += scene.toField("viewport", Viewport.typeRef)
		if(scene.hasScore) {
			scene.score.displays.forEach[
				type.members += scene.toField('''«it.name»TimeCount''', float.typeRef) [initializer = [append("0")]]
				var displayField = scene.toField('''«it.name»''', it.type.getName.typeRef)
				val current = it			
				displayField.initializer = [append('''«IF current.hasInitial»«IF current.type == GameDisplayValueType.STRING»"«current.initialStringValue»"«ELSEIF current.type == GameDisplayValueType.FLOAT»«current.initialNumberValue»«ELSEIF current.type == GameDisplayValueType.INT»«current.initialIntValue»«ENDIF»«ELSE»«IF current.type == GameDisplayValueType.STRING»""«ELSEIF current.type == GameDisplayValueType.FLOAT»0.0«ELSEIF current.type == GameDisplayValueType.INT»0«ENDIF»«ENDIF»''')]
				if(it.hasAdder||it.hasSetter) {
					displayField.static = true
				}
				type.members += displayField
				type.members += scene.toField('''«it.name»TitleLabel''', Label.typeRef)
				var valueField = scene.toField('''«it.name»ValueLabel''', Label.typeRef)
				if(it.hasAdder||it.hasSetter) {
					valueField.static = true
				}
				type.members += valueField 
			]
		}
	}

	def void toOperations(JvmGenericType type, GameScene scene) {
		type.members += scene.toMethod("update", Void.TYPE.typeRef, [
			parameters += scene.toParameter("dt", float.typeRef)
			body = [
				val current = it
				if(scene.hasScore) {
					scene.score.displays.filter[it.hasDelta].forEach[
						current.append(
						'''
						«it.name»TimeCount += dt;
						if («it.name»TimeCount >= «it.timePeriod») {
							«it.name» += «it.deltaValue»;
							«it.name»ValueLabel.setText(String.format("«it.format»", «it.name»));
							«it.name»TimeCount = 0;
						}
						''')
					]
				}
			]
		])
		type.members += scene.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				stage.dispose();
				''')
			]
		])
		if(scene.hasScore) {
			scene.score.displays.filter[it.hasAdder].forEach[
				val current = it
				var operation = scene.toMethod('''add«it.name.toFirstUpper»''', Void.TYPE.typeRef, [
					parameters += scene.toParameter("value", current.type.getName.typeRef)
					body = [
						append(
						'''
						«current.name» += value;
						«current.name»ValueLabel.setText(String.format("«current.format»", «current.name»));
						''')
					]
				])
				operation.static = true
				type.members += operation 
			]
			scene.score.displays.filter[it.hasSetter].forEach[
				val current = it
				var operation = scene.toMethod('''set«it.name.toFirstUpper»''', Void.TYPE.typeRef, [
					parameters += scene.toParameter("value", current.type.getName.typeRef)
					body = [
						append(
						'''
						«current.name» = value;
						«current.name»ValueLabel.setText(String.format("«current.format»", «current.name»));
						''')
					]
				])
				operation.static = true
				type.members += operation 
			]
		}
	}

	// sprites
	def void createSprite(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, JvmGenericType screenClass, GameSprite sprite) {
		acceptor.accept(
			gamePkg.toClass(sprite.fullyQualifiedName),
			[
				superTypes += Sprite.typeRef
				packageName = sprite.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toFields(sprite)
				members += sprite.toConstructor [
					parameters += gamePkg.toParameter("screen", screenClass.typeRef)
					if(!sprite.hasStartPosition) {
						parameters += gamePkg.toParameter("x", float.typeRef)
						parameters += gamePkg.toParameter("y", float.typeRef)
					}
					body = [
						append(
						'''
						world = screen.getWorld();
						stateTimer = 0;
						float xPosition = «IF sprite.hasStartPosition»«sprite.startPosition.x»f«ELSE»x«ENDIF»;
						float yPosition = «IF sprite.hasStartPosition»«sprite.startPosition.y»f«ELSE»y«ENDIF»;
						''')
						append(Array)
						append("<")
						append(TextureRegion)
						append("> frames = new Array<TextureRegion>();\n")
						val current = it
						sprite.states.forEach[
							if(it.animation !== null) {
								if(it.animation.hasFrames) {
									current.append(
									'''
									for (int i = «it.animation.offset»; i < «it.animation.frames+it.animation.offset»; i++) {
										TextureRegion «it.animation.name»TextureRegion = new TextureRegion(screen.getAtlas().findRegion("«it.animation.region.region»"), i * «it.animation.region.width», 0, «it.animation.region.width», «it.animation.region.height»);
										«it.animation.name»TextureRegion.flip(«it.animation.region.flipX.booleanValue», «it.animation.region.flipY.booleanValue»); 
										frames.add(«it.animation.name»TextureRegion);
									}
									''')
								}
								if(it.animation.hasStands) {
									it.animation.stands.forEach[
										current.append(
										'''
										TextureRegion «it.name»TextureRegion = new TextureRegion(screen.getAtlas().findRegion("«it.region.region»"), «it.offset*it.region.width», 0, «it.region.width», «it.region.height»);
										«it.name»TextureRegion.flip(«it.region.flipX.booleanValue», «it.region.flipY.booleanValue»); 
										frames.add(«it.name»TextureRegion);
										''')
									]
									
								}
								current.append(
								'''
								«it.animation.name» = new ''')
								current.append(Animation)
								current.append('''
								<TextureRegion>(«it.animation.duration»f, frames);
								frames.clear();
								''')
							}
							if(it.stand !== null) {
								current.append(
									'''
									«it.stand.name» = new TextureRegion(screen.getAtlas().findRegion("«it.stand.region.region»"), «it.stand.offset*it.stand.region.width», 0, «it.stand.region.width», «it.stand.region.height»);
									«it.stand.name».flip(«it.stand.region.flipX.booleanValue», «it.stand.region.flipY.booleanValue»); 
									'''
								)
							}
						]
						append(
						'''
				        define«sprite.name.toFirstUpper»(new Vector2(xPosition / ''')
				        append(gameClass)
				        append('''.PPM, yPosition / «gameClass.simpleName».PPM));
				        ''')
						append("setRegion(getFrame(0.0f));\n");
					]
				]
				it.toOperations(sprite, gameClass)
			]
		)
	}

	def void toFields(JvmGenericType type, GameSprite sprite) {
		var field = sprite.toField("world", World.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = sprite.toField("body", Body.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		type.members += sprite.toField("stateTimer", float.typeRef)
		
		var stateType = sprite.toEnumerationType("State") [
			sprite.states.forEach [ state |
				members += state.toEnumerationLiteral(state.name.toUpperCase)
			]
		]
		sprite.states.forEach [ state |		
			if(state.animation !== null) {
				type.members += sprite.toField(state.animation.name, Animation.typeRef(TextureRegion.typeRef))
			}
			if(state.stand !== null) {
				type.members += sprite.toField(state.stand.name, TextureRegion.typeRef)
			}
		]
		type.members += stateType
		type.members += sprite.toField("currentState", typeRef(stateType)) [initializer=[append('''State.«sprite.initialState.name.toUpperCase»''')]]
		type.members += sprite.toField("previousState", typeRef(stateType)) [initializer=[append('''State.«sprite.initialState.name.toUpperCase»''')]]
		type.members += sprite.toField("positionOffsetX", float.typeRef) [initializer=[append('''0.0f''')]]
		type.members += sprite.toField("positionOffsetY", float.typeRef) [initializer=[append('''0.0f''')]]
		if(sprite.hasVelocity) {
			type.members += sprite.toField("velocity", Vector2.typeRef) [initializer=[append('''new Vector2(«sprite.velocity.x»f,«sprite.velocity.y»f)''')]]
		}
		val fsprite = sprite
		sprite.properties.forEach[
			type.members += fsprite.toField('''«it.name»''', Boolean.typeRef)  [initializer=[append('''false''')]]
		]
		type.members += sprite.toGetter("currentState", typeRef(stateType))
	}

	def void toOperations(JvmGenericType type, GameSprite sprite, JvmGenericType gameClass) {
		val i = 0 as int
		for(state: sprite.states) {
			type.members += sprite.toMethod('''is«state.rule.name.toFirstUpper»''', boolean.typeRef) [
				documentation = state.rule.documentation
				for (p : state.rule.params) {
					parameters += p.toParameter(p.name, p.parameterType)
				}
				body = state.rule.body
			]
		}
		val fsprite = sprite
		sprite.properties.forEach[
			val prop = it
			type.members += fsprite.toMethod('''is«it.name.toFirstUpper»''', Boolean.typeRef, [
				body = [
					append(
					'''
					return «prop.name»;
					''')
				]
			])
		]
		sprite.properties.forEach[
			val prop = it
			type.members += fsprite.toMethod('''set«it.name.toFirstUpper»''', Void.TYPE.typeRef, [
				parameters += sprite.toParameter("value", Boolean.typeRef)
				body = [
					append(
					'''
					«prop.name» = value;
					''')
				]
			])
		]
		
		sprite.properties.filter[it.onUpdateTrue].forEach[
			val prop = it
			type.members += sprite.toMethod('''doTrue«it.name.toFirstUpper»''', Void.TYPE.typeRef) [
				documentation = prop.documentation
				body = prop.body
			]
		]

		sprite.properties.filter[it.onUpdateFalse].forEach[
			val prop = it
			type.members += sprite.toMethod('''doFalse«it.name.toFirstUpper»''', Void.TYPE.typeRef) [
				documentation = prop.documentation
				body = prop.body
			]
		]
		
		type.members += sprite.toMethod("update", Void.TYPE.typeRef, [
			parameters += sprite.toParameter("dt", float.typeRef)
			body = [
				append(
				'''
				setPosition(body.getPosition().x - getWidth() / 2, body.getPosition().y - getHeight() / 2);
				''')
				val current = it
				sprite.properties.filter[it.onUpdateTrue].forEach[
					current.append(
					'''
					if(«it.name») {
						doTrue«it.name.toFirstUpper»();
					}
					''')
				]
				sprite.properties.filter[it.onUpdateFalse].forEach[
					current.append(
					'''
					if(!«it.name») {
						doFalse«it.name.toFirstUpper»();
					}
					''')
				]
				append(
				'''
				setRegion(getFrame(dt));
				''')
			]
		])
		type.members += sprite.toMethod("getFrame", TextureRegion.typeRef, [
			parameters += sprite.toParameter("dt", float.typeRef)
			body = [
				append(
				'''
		        currentState = getState();
		        TextureRegion region = null;
		        switch (currentState) {
		        ''')
		        val current = it
				sprite.states.forEach[
					current.append(
					'''
					case «it.name.toUpperCase»:
						region = «IF it.animation!==null»«it.animation.name».getKeyFrame(stateTimer)«ELSEIF it.stand!==null»«it.stand.name»«ENDIF»;
						«IF it.animation!==null && it.ifFinished»if(«it.animation.name».isAnimationFinished(stateTimer)) {
							set«setFalse.name.toFirstUpper»(false);
						}«ENDIF»
						positionOffsetX = «IF it.animation!==null»«IF it.animation.hasFrames»«it.animation.region.offsetX»f«ELSEIF it.animation.hasStands»«it.animation.stands.get(0).region.offsetX»f«ENDIF»«ELSEIF it.stand!==null»«it.stand.region.offsetX»f«ENDIF»;
						positionOffsetY = «IF it.animation!==null»«IF it.animation.hasFrames»«it.animation.region.offsetY»f«ELSEIF it.animation.hasStands»«it.animation.stands.get(0).region.offsetY»f«ENDIF»«ELSEIF it.stand!==null»«it.stand.region.offsetY»f«ENDIF»;
						break;
					''')
				]		        	
				append(
				'''
		        }
		        stateTimer = currentState == previousState ? stateTimer + dt : 0;
		        previousState = currentState;
		        return region;
				''')
			]
		])
		type.members += sprite.toMethod("getState", "State".typeRef, [
			body = [
				for(state: sprite.states) {
					append(
					'''
					if(is«state.rule.name.toFirstUpper»()) {
						return State.«state.name.toUpperCase»;
					}
					''')
				}
				append(
				'''
				return State.«sprite.initialState.name.toUpperCase»;
				''')
			]
		])
		type.members += sprite.toMethod('''redefine«sprite.name.toFirstUpper»''', Void.TYPE.typeRef, [
			body = [
				append(
				'''
				Vector2 position = body.getPosition();
				world.destroyBody(body);
				position.add(positionOffsetX / «gameClass.simpleName».PPM, positionOffsetY / «gameClass.simpleName».PPM); 
				define«sprite.name.toFirstUpper»(position);
				''')
			]
		])
		type.members += sprite.toMethod('''define«sprite.name.toFirstUpper»''', Void.TYPE.typeRef, [
			parameters += sprite.toParameter("position", Vector2.typeRef)
			body = [
				append(BodyDef)
				append('''
				 bdef = new BodyDef();
				bdef.position.set(position);
				bdef.type = BodyDef.BodyType.DynamicBody;
				body = world.createBody(bdef);
				''')
				append(FixtureDef)
				append(''' fdef = new FixtureDef();
				''')
				append(CircleShape)
				append('''
				 shape = new CircleShape();
				shape.setRadius(«sprite.radius» / «gameClass.simpleName».PPM);
				fdef.filter.categoryBits = «(2**sprite.id) as int»;
				''')
				var mask = 0.0
				for(actor:sprite.actors) {
					if(actor.sprite !== null) {
						mask = mask + (2**actor.sprite.id)
					} else if(actor.tile !== null) {
						mask = mask + (2**actor.tile.id)
					}
				}
				append('''
				fdef.filter.maskBits = «mask as int»;
				fdef.shape = shape;
				shape.setPosition(new Vector2(-positionOffsetX / «gameClass.simpleName».PPM, -positionOffsetY / «gameClass.simpleName».PPM));
				body.createFixture(fdef).setUserData(this);
				''')
				if(sprite.hasSensor) {
					if(sprite.vectors2d.length==2) {
						append(EdgeShape)
					} else {
						append(PolygonShape)
					}
					append(
					''' head = new «IF sprite.vectors2d.length==2»Edge«ELSE»Polygon«ENDIF»Shape();
					''')
					if(sprite.vectors2d.length==2) {
						append(
						'''
						head.set(new Vector2(«sprite.vectors2d.get(0).x»f / 2 / «gameClass.simpleName».PPM, «sprite.radius» / «gameClass.simpleName».PPM), new Vector2(«sprite.vectors2d.get(0).y»f / 2 / «gameClass.simpleName».PPM, «sprite.radius» / «gameClass.simpleName».PPM));
						''')
					} else {
						append(
						'''
						Vector2[] vertice = new Vector2[«sprite.vectors2d.length»];
						''')
						for(var idx=0;idx<sprite.vectors2d.length;idx++) {
							append(
							'''
							vertice[«idx»] = new Vector2(«sprite.vectors2d.get(idx).x»f, «sprite.vectors2d.get(idx).y»f).scl(1 / «gameClass.simpleName».PPM);
							''')
						}
						append(
						'''
						head.set(vertice);
						''')
					}
					append(
					'''
					fdef.filter.categoryBits = «(2**sprite.sensorID) as int»;
					fdef.shape = head;
					fdef.isSensor = true;
					body.createFixture(fdef).setUserData(this);
					''')
				}
		        if(sprite.initialState.animation !== null) {
		        	if(sprite.initialState.animation.hasFrames) {
			        	append(
			        	'''
			        	setBounds(position.x, position.y, «sprite.initialState.animation.region.width» / «gameClass.simpleName».PPM, «sprite.initialState.animation.region.height» / «gameClass.simpleName».PPM);
			        	''')
			        }
		        	if(sprite.initialState.animation.hasStands) {
			        	append(
			        	'''
			        	setBounds(position.x, position.y, «sprite.initialState.animation.stands.get(0).region.width» / «gameClass.simpleName».PPM, «sprite.initialState.animation.stands.get(0).region.height» / «gameClass.simpleName».PPM);
			        	''')
			        }
		        }
		        if(sprite.initialState.stand !== null) {
		        	append(
		        	'''
		        	setBounds(position.x, position.y, «sprite.initialState.stand.region.width» / «gameClass.simpleName».PPM, «sprite.initialState.stand.region.height» / «gameClass.simpleName».PPM);
		        	''')
		        }
			]
		])
		sprite.events.forEach[
			val event = it
			type.members += sprite.toMethod('''«it.name»''', Void.TYPE.typeRef, [
				documentation = it.documentation
				for (p : event.params) {
					parameters += p.toParameter(p.name, p.parameterType)
				}
				body = event.body
			])		
		]
	}

	// tiles
	def void createTile(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, JvmGenericType screenClass, GameTile tile, GameRoot root) {
		acceptor.accept(
			gamePkg.toClass(tile.fullyQualifiedName),
			[
				packageName = tile.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toFields(tile, screenClass)
				members += tile.toConstructor [
					parameters += gamePkg.toParameter("screen", screenClass.typeRef)
					parameters += gamePkg.toParameter("object", MapObject.typeRef)
					body = [
						append(
						'''
						this.screen = screen;
						this.object = object;
						world = screen.getWorld();
						map = screen.getMap();
						bounds = ((''')
						append(RectangleMapObject)
						append(
						''' 
						)object).getRectangle();
						''')
						append(BodyDef)
						append(''' bdef = new BodyDef();
						''')
						append(FixtureDef)
						append(''' fdef = new FixtureDef();
						''')
						append(PolygonShape)
						append(
						'''
						 shape = new PolygonShape();
						bdef.type = BodyDef.BodyType.StaticBody;
						bdef.position.set((bounds.getX() + bounds.getWidth() / 2) /''') 
						append(gameClass)
						append(
						'''
						.PPM, (bounds.getY() + bounds.getHeight() / 2) / «gameClass.simpleName».PPM);
						body = world.createBody(bdef);
						shape.setAsBox(bounds.getWidth() / 2 / «gameClass.simpleName».PPM, bounds.getHeight() / 2 / «gameClass.simpleName».PPM);
						fdef.filter.categoryBits = «(2**tile.id) as int»;
						fdef.shape = shape;
						fixture = body.createFixture(fdef);
						fixture.setUserData(this);
						''')
					]
				]
				if(tile.hasTileLayer) {
					it.toOperations(tile, gameClass, root)
				}
			]
		)
	}

	def void toFields(JvmGenericType type, GameTile tile, JvmGenericType screenClass) {
		var field = tile.toField("world", World.typeRef)
		type.members += field
		field = tile.toField("map", TiledMap.typeRef)
		type.members += field
		field = tile.toField("tile", TiledMapTile.typeRef)
		type.members += field
		field = tile.toField("bounds", Rectangle.typeRef)
		type.members += field
		field = tile.toField("body", Body.typeRef)
		type.members += field
		field = tile.toField("screen", screenClass.typeRef)
		type.members += field
		field = tile.toField("object", MapObject.typeRef)
		type.members += field
		field = tile.toField("fixture", Fixture.typeRef)
		type.members += field
	}

	def void toOperations(JvmGenericType type, GameTile tile, JvmGenericType gameClass, GameRoot root) {
		type.members += tile.toMethod("getMap", TiledMap.typeRef, [
			body = [
				append('''return map;''')
			]
		])
		type.members += tile.toMethod("getCell", TiledMapTileLayer.Cell.typeRef, [
			body = [
				append(TiledMapTileLayer)
				append(''' layer = (TiledMapTileLayer) map.getLayers().get(«tile.tileLayer.index»);
				''')
				append('''return  layer.getCell((int) (body.getPosition().x * «gameClass.simpleName».PPM / «root.tileWidth»), (int) (body.getPosition().y * «gameClass.simpleName».PPM / «root.tileHeight»));
				''')
			]
		])
		type.members += tile.toMethod("setCategoryFilter", Void.TYPE.typeRef, [
			parameters += tile.toParameter("filterBit", int.typeRef)
			body = [
				append(Filter)
				append(''' filter = new Filter();
				''')
				append(
				'''
				filter.categoryBits = (short)filterBit;
				fixture.setFilterData(filter);
				''')
			]
		])
	}

	// creator
	def void createCreator(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType creatorClass, JvmGenericType gameClass, JvmGenericType screenClass, GameScreen screen, GameRoot game) {
		acceptor.accept(
			creatorClass,
			[
				packageName = game.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toCreatorFields(game, screen)
				members += game.toConstructor [
					parameters += gamePkg.toParameter("screen", screenClass.typeRef)
					body = [
						append(
						'''
						world = screen.getWorld();
						map = screen.getMap();
						''')
						val current = it
						screen.tiles.filter[it.hasObjectLayer].forEach[
							current.append(
							'''
							for(''')
							current.append(MapObject)
							current.append(''' object : map.getLayers().get(«it.objectLayer.index»).getObjects().getByType(''')
							current.append(RectangleMapObject)
							current.append(
							'''
							.class)){
							''')
							current.append('''	new «it.fullyQualifiedName.skipLast(1).toString».«it.name.toFirstUpper»(screen, object);''')
							current.append("\n}\n")
						]
						screen.sprites.filter[it.hasLayer].forEach[
							var spriteFQN = '''«it.fullyQualifiedName.skipLast(1).toString».«it.name.toFirstUpper»''' 
							current.append('''«it.name.toFirstLower» = new ''')
							current.append(Array)
							current.append('''<«spriteFQN»>();
							''')
							current.append(
							'''
							for(''')
							current.append(MapObject)
							current.append(''' object : map.getLayers().get(«it.layer.index»).getObjects().getByType(''')
							current.append(RectangleMapObject)
							current.append(
							'''
							.class)){
							''')
							current.append('''	''')
							current.append(Rectangle)
							current.append(''' rect = ((''')
							current.append(RectangleMapObject)
							current.append(''') object).getRectangle();
							''')
							current.append('''	«it.name.toFirstLower».add(new «spriteFQN»(screen, rect.getX(), rect.getY()));
							''')
							current.append("\n}\n")
						]
					]
				]
				it.toCreatorOperations(game, screen, gameClass)
			]
		)
	}

	def void toCreatorFields(JvmGenericType type, GameRoot game, GameScreen screen) {
		var field = game.toField("world", World.typeRef)
		type.members += field
		field = game.toField("map", TiledMap.typeRef)
		type.members += field
		screen.sprites.filter[it.hasLayer].forEach[
			var spriteFQN = '''«it.fullyQualifiedName.skipLast(1).toString».«it.name.toFirstUpper»'''
			var array = game.toField(it.name.toFirstLower, Array.typeRef(spriteFQN.typeRef))
			array.visibility = JvmVisibility.PRIVATE
			type.members += array
		]
	}

	def void toCreatorOperations(JvmGenericType type, GameRoot game, GameScreen screen, JvmGenericType gameClass) {
		type.members += game.toMethod("updateSprites", Void.TYPE.typeRef, [
			parameters += game.toParameter("dt", float.typeRef)
			parameters += game.toParameter("playerXPosition", float.typeRef)
			body = [
				val current = it
				screen.sprites.filter[it.hasLayer].forEach[
					val spriteFQN = '''«it.fullyQualifiedName.skipLast(1).toString».«it.name.toFirstUpper»'''
					var array = game.toField(it.name.toFirstLower, Array.typeRef(spriteFQN.typeRef))
					current.append("for(")
					current.append(spriteFQN)
					current.append(''' sprite:«it.name.toFirstLower») {
					''')
					current.append("	sprite.update(dt);\n")
					current.append('''	if(sprite.getX() < playerXPosition + «game.worldWidth-game.tileWidth» / «gameClass.simpleName».PPM) {
					''')
					current.append("		sprite.body.setActive(true);\n")
					current.append('''	}
					''')
					current.append(
					'''
					}''')
				]
				
			]
		])
		type.members += game.toMethod("drawSprites", Void.TYPE.typeRef, [
			parameters += game.toParameter("batch", Batch.typeRef)
			body = [
				val current = it
				screen.sprites.filter[it.hasLayer].forEach[
					val spriteFQN = '''«it.fullyQualifiedName.skipLast(1).toString».«it.name.toFirstUpper»'''
					var array = game.toField(it.name.toFirstLower, Array.typeRef(spriteFQN.typeRef))
					current.append("for(")
					current.append(spriteFQN)
					current.append(''' sprite:«it.name.toFirstLower») {
					''')
					current.append("	sprite.draw(batch);\n")
					current.append(
					'''
					}''')
				]
				
			]
		])
	}

	// contact
	def void createContactListener(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType contactClass, GameRoot game) {
		acceptor.accept(
			contactClass,
			[
				superTypes += ContactListener.typeRef
				packageName = game.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toContactOperations(game)
			]
		)
	}

	def void toContactOperations(JvmGenericType type, GameRoot game) {
		type.members += game.toMethod("beginContact", Void.TYPE.typeRef, [
			parameters += game.toParameter("contact", Contact.typeRef)
			body = [
				append(Fixture)
				append(
				''' fixA = contact.getFixtureA();
				''')
				append(
				'''
				Fixture fixB = contact.getFixtureB();
				int cDef = fixA.getFilterData().categoryBits | fixB.getFilterData().categoryBits;
				switch(cDef) {
				''')
				val current = it
				game.screens.forEach[screen|
					screen.sprites.forEach[sprite|
						sprite.actors.filter[it.hasCollision && it.beginContact !== null].forEach[actor|
							current.append(decodeCollision(actor, sprite, actor.beginContact.name))
						]
					]
				]
				append(
				'''
				}
				''')
			]
		])
		type.members += game.toMethod("endContact", Void.TYPE.typeRef, [
			parameters += game.toParameter("contact", Contact.typeRef)
			body = [
				append(Fixture)
				append(
				''' fixA = contact.getFixtureA();
				''')
				append(
				'''
				Fixture fixB = contact.getFixtureB();
				int cDef = fixA.getFilterData().categoryBits | fixB.getFilterData().categoryBits;
				switch(cDef) {
				''')
				val current = it
				game.screens.forEach[screen|
					screen.sprites.forEach[sprite|
						sprite.actors.filter[it.hasCollision && it.endContact !== null].forEach[actor|
							current.append(decodeCollision(actor, sprite, actor.endContact.name))
						]
					]
				]
				append(
				'''
				}
				''')
			]
		])
		type.members += game.toMethod("preSolve", Void.TYPE.typeRef, [
			parameters += game.toParameter("contact", Contact.typeRef)
			parameters += game.toParameter("oldManifold", Manifold.typeRef)
			body = [
				append('''
				''')
			]
		])
		type.members += game.toMethod("postSolve", Void.TYPE.typeRef, [
			parameters += game.toParameter("contact", Contact.typeRef)
			parameters += game.toParameter("impulse", ContactImpulse.typeRef)
			body = [
				append('''
				''')
			]
		])
	}
	
	protected def decodeCollision(GameActor actor, GameSprite sprite, String methodName) {
		var id1 = 0
		if(actor.typeA==GameContactType.FIXTURE) {
			id1 = (2**sprite.id) as int
		} else if(actor.typeA==GameContactType.SENSOR) {
			id1 = (2**sprite.sensorID) as int
		}
		var id2 = 0
		if(actor.sprite !== null) {
			if(actor.typeB==GameContactType.FIXTURE) {
				id2 = (2**actor.sprite.id) as int
			} else if(actor.typeB==GameContactType.SENSOR) {
				id2 = (2**actor.sprite.sensorID) as int
			}
		} else if (actor.tile !== null) {
			id2 = (2**actor.tile.id) as int
		}
		return
		'''
		case «id1+id2»:
			if(fixA.getFilterData().categoryBits == «id1») {
				((«sprite.fullyQualifiedName»)fixA.getUserData()).«methodName»((«IF actor.sprite!==null»«actor.sprite.name.toFirstUpper»«ELSEIF actor.tile!==null»«actor.tile.fullyQualifiedName»«ENDIF»)fixB.getUserData());
			} else {
				((«sprite.fullyQualifiedName»)fixB.getUserData()).«methodName»((«IF actor.sprite!==null»«actor.sprite.name.toFirstUpper»«ELSEIF actor.tile!==null»«actor.tile.fullyQualifiedName»«ENDIF»)fixA.getUserData());
			}
			break;
		'''
	}
}
