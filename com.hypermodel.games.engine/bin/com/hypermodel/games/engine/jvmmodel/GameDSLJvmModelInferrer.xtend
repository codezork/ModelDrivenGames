package com.hypermodel.games.engine.jvmmodel

import android.os.Bundle
import com.badlogic.gdx.ApplicationListener
import com.badlogic.gdx.Game
import com.badlogic.gdx.Screen
import com.badlogic.gdx.audio.Music
import com.badlogic.gdx.backends.android.AndroidApplication
import com.badlogic.gdx.backends.gwt.GwtApplication
import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration
import com.badlogic.gdx.backends.iosrobovm.IOSApplication
import com.badlogic.gdx.graphics.OrthographicCamera
import com.badlogic.gdx.graphics.g2d.SpriteBatch
import com.badlogic.gdx.graphics.g2d.TextureAtlas
import com.badlogic.gdx.maps.tiled.TiledMap
import com.badlogic.gdx.maps.tiled.TmxMapLoader
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer
import com.badlogic.gdx.physics.box2d.Box2DDebugRenderer
import com.badlogic.gdx.physics.box2d.World
import com.badlogic.gdx.utils.viewport.Viewport
import com.google.gwt.event.logical.shared.ResizeEvent
import com.google.gwt.event.logical.shared.ResizeHandler
import com.hypermodel.games.engine.gameDSL.GamePackage
import com.hypermodel.games.engine.gameDSL.GameRoot
import com.hypermodel.games.engine.gameDSL.GameScreen
import com.hypermodel.games.engine.generator.GameProperties
import com.hypermodel.games.engine.generator.GameProperties.ProjectType
import javax.inject.Inject
import org.eclipse.xtext.common.types.JvmField
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.moe.natj.general.Pointer

class GameDSLJvmModelInferrer extends AbstractModelInferrer {
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider

	def dispatch void infer(GamePackage gamePkg, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		for (game : gamePkg.games) {
			// core module
			var rootClass = gamePkg.toClass(game.fullyQualifiedName) 
			acceptor.accept(
				rootClass,
				[
					superTypes += Game.typeRef
					packageName = game.fullyQualifiedName.skipLast(1).toString
					documentation = "generated by hypermodels.com"
					it.toFields(game)
					it.toOperations(gamePkg, game)
				]
			)
			// launchers
			for (pType : ProjectType.values) {
				if (pType != ProjectType.core) {
					acceptor.createLauncher(gamePkg, game, pType)
				}
			}
			// screens
			for (screen : game.screens) {
				acceptor.createScreen(gamePkg, rootClass, screen)
			}
		}
	}

	protected def void createLauncher(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, GameRoot game, ProjectType pType) {
		val doc = "generated by hypermodels.com"
		switch (pType) {
			case ProjectType.android: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				launcherClass.superTypes.add(AndroidApplication.typeRef)
				acceptor.accept(
					launcherClass,
					[
						var method = game.toMethod("onCreate", Void.TYPE.typeRef, [
							parameters += game.toParameter("savedInstanceState", Bundle.typeRef)
							annotations += _annotationTypesBuilder.annotationRef(Override)
							body = [
								append(
								'''
								super.onCreate(savedInstanceState);
								AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
								«IF gamePkg.config.android.useAccelerometer»config.useAccelerometer = true;«ENDIF»
								initialize(new «game.name.toFirstUpper»(), config);''')
							]
						])
						it.members += method
						packageName = gamePkg.fullyQualifiedName.toString
						documentation = doc
					]
				)
			}
			case ProjectType.desktop: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				acceptor.accept(
					launcherClass,
					[
						var method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
								new LwjglApplication(new «game.fullyQualifiedName»(), config);''')
							]
						])
						method.static = true
						it.members += method
						packageName = '''«gamePkg.fullyQualifiedName.toString».«pType.name»'''
						documentation = doc
					]
				)
			}
			case ProjectType.html: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				launcherClass.superTypes.add(GwtApplication.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = '''«gamePkg.fullyQualifiedName.toString».client'''
						documentation = doc
						var field = game.toField("PADDING", int.typeRef, [
							initializer = [append('''0''')]
						])
						it.members += field
						field = game.toField("cfg", GwtApplicationConfiguration.typeRef)
						it.members += field
						var method = game.toMethod("getConfig", GwtApplicationConfiguration.typeRef, [
								annotations += _annotationTypesBuilder.annotationRef(Override)
								body = [
									append(
								'''
									int w = Window.getClientWidth() - PADDING;
									int h = Window.getClientHeight() - PADDING;
									cfg = new GwtApplicationConfiguration(w, h);
									Window.enableScrolling(false);
									Window.setMargin("0");
									Window.addResizeHandler(new ResizeListener());
									cfg.preferFlash = false;
									return cfg;''')
								]
							])
						it.members += method
						method = game.toMethod("createApplicationListener", ApplicationListener.typeRef, [
								annotations += _annotationTypesBuilder.annotationRef(Override)
								body = [
									append(
								'''
									return new «game.fullyQualifiedName»();''')
								]
							])
						it.members += method
						val resizeClass = gamePkg.toClass("ResizeListener");
						resizeClass.superTypes.add(ResizeHandler.typeRef)
						var innermethod = game.toMethod("onResize", Void.TYPE.typeRef, [
							parameters += game.toParameter("event", ResizeEvent.typeRef)
							annotations += _annotationTypesBuilder.annotationRef(Override)
							body = [
								append(
								'''
								int width = event.getWidth() - PADDING;
								int height = event.getHeight() - PADDING;
								getRootPanel().setWidth("" + width + "px");
								getRootPanel().setHeight("" + height + "px");
								getApplicationListener().resize(width, height);
								Gdx.graphics.setWindowedMode(width, height);''')
							]
						])
						resizeClass.members += innermethod
						it.members += resizeClass
					]
				)
			}
			case ProjectType.ios: {
				val launcherClass = gamePkg.toClass('''«pType.name.toUpperCase»Launcher''');
				launcherClass.superTypes.add(IOSApplication.Delegate.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = '''«gamePkg.fullyQualifiedName.toString»'''
						documentation = doc
						var method = game.toMethod("createApplication", IOSApplication.typeRef, [
							annotations += _annotationTypesBuilder.annotationRef(Override)
							body = [
								append(
								'''
								IOSApplicationConfiguration config = new IOSApplicationConfiguration();
								«IF gamePkg.config.ios.useAccelerometer»config.useAccelerometer = true;«ENDIF»
								return new IOSApplication(new «game.name.toFirstUpper»(), config);''')
							]
						])
						it.members += method
						method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								NSAutoreleasePool pool = new NSAutoreleasePool();
								UIApplication.main(arg, null, «pType.name.toUpperCase»«GameProperties.launcherPostfix».class);
								pool.close();''')
							]
						])
						method.static = true
						it.members += method
					]
				)
			}
			case ProjectType.iosmoe: {
				val launcherClass = gamePkg.toClass('''«pType.name.toUpperCase»Launcher''');
				launcherClass.superTypes.add(com.badlogic.gdx.backends.iosmoe.IOSApplication.Delegate.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = gamePkg.fullyQualifiedName.toString
						documentation = doc
						var constructor = game.toConstructor( [
							parameters += game.toParameter("peer", Pointer.typeRef)
							body = [
								append(
								'''
								super(peer);''')
							]
						])
						constructor.visibility = JvmVisibility.PROTECTED
						it.members += constructor
						var method = game.toMethod("createApplication",	com.badlogic.gdx.backends.iosmoe.IOSApplication.typeRef, [
								annotations += _annotationTypesBuilder.annotationRef(Override)
								body = [
									append(
								'''
									IOSApplicationConfiguration config = new IOSApplicationConfiguration();
									«IF gamePkg.config.iosmoe.useAccelerometer»config.useAccelerometer = true;«ENDIF»
									return new IOSApplication(new «game.name.toFirstUpper»(), config);''')
								]
							])
						it.members += method
						method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								UIKit.UIApplicationMain(0, null, null, «pType.name.toUpperCase»«GameProperties.launcherPostfix».class.getName());''')
							]
						])
						method.static = true
						it.members += method
					]
				)
			}
			default: {
			}
		}
	}

	def void toFields(JvmGenericType type, GameRoot game) {
		var JvmField field = null
		field = game.toField("batch", SpriteBatch.typeRef)
		type.members += field
		field = game.toField("V_WIDTH", int.typeRef)[initializer = [append('''«game.width»''')]]
		field.static = true
		field.final = true
		type.members += field
		field = game.toField("V_HEIGHT", int.typeRef) [
			initializer = [append('''«game.height»''')]
		]
		field.static = true
		field.final = true
		type.members += field
		field = game.toField("TITLE", String.typeRef) [
			initializer = [append('''"«game.title»"''')]
		]
		field.static = true
		field.final = true
		type.members += field
		field = game.toField("PPM", float.typeRef)[initializer = [append('''«game.ppm»f''')]]
		field.static = true
		field.final = true
		type.members += field
	}

	def void toOperations(JvmGenericType type, GamePackage gamePkg, GameRoot game) {
		type.members += game.toMethod("create", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				it.append(
				'''
				batch = new SpriteBatch();
				''')
				for (screen : game.screens) {
					it.append("setScreen(new ")
					it.append(gamePkg.toClass(screen.fullyQualifiedName))
					it.append("(this));")
				}
			]
		])

		type.members += game.toMethod("render", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				append(
				'''
				super.render();''')
			]
		])
		type.members += game.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				append(
				'''
				super.dispose();
				batch.dispose();''')
			]
		])
	}

	def void createScreen(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, GameScreen screen) {
		acceptor.accept(
			gamePkg.toClass(screen.fullyQualifiedName),
			[
				superTypes += Screen.typeRef
				packageName = screen.fullyQualifiedName.skipLast(1).toString
				documentation = "generated by hypermodels.com"
				it.toFields(screen, gameClass)
				members += screen.toConstructor [
					parameters += gamePkg.toParameter("game", gameClass.typeRef)
					body = [
						append(
						'''
						this.game = game;
						atlas = new TextureAtlas("«screen.atlasName».pack");
						''')
					]
				]
				it.toOperations(screen)
			]
		)
	}

	def void toFields(JvmGenericType type, GameScreen screen, JvmGenericType gameClass) {
		var JvmField field = null
		type.members += screen.toField("game", gameClass.typeRef)
		type.members += screen.toField("atlas", TextureAtlas.typeRef)
		type.members += screen.toField("gamecam", OrthographicCamera.typeRef);
		type.members += screen.toField("gamePort", Viewport.typeRef);
		type.members += screen.toField("mapLoader", TmxMapLoader.typeRef);
		type.members += screen.toField("map", TiledMap.typeRef);
		type.members += screen.toField("renderer", OrthogonalTiledMapRenderer.typeRef);
		type.members += screen.toField("world", World.typeRef);
		type.members += screen.toField("b2dr", Box2DDebugRenderer.typeRef);
		type.members += screen.toField("music", Music.typeRef);
//		type.members += screen.toField("creator", B2WorldCreator.typeRef);
//		type.members += screen.toField("player", Mario.typeRef);
//		type.members += screen.toField("items", Array, Item.typeRef)) ;
//		type.members += screen.toField("itemsToSpawn", LinkedBlockingQueue, ItemDef.typeRef)) ;
//		field = screen.toField("hud", Hud.typeRef)
//		field.visibility = JvmVisibility.PUBLIC 
//		type.members += field
	}

	def void toOperations(JvmGenericType type, GameScreen screen) {
		type.members += screen.toGetter("atlas", TextureAtlas.typeRef)
		type.members += screen.toMethod("resize", Void.TYPE.typeRef(), [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			parameters += screen.toParameter("width", int.typeRef())
			parameters += screen.toParameter("height", int.typeRef())
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("pause", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("resume", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("show", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("render", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			parameters += screen.toParameter("delta", float.typeRef)
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("hide", Void.TYPE.typeRef, [
			annotations += _annotationTypesBuilder.annotationRef(Override)
			body = [
				append(
				'''
				''')
			]
		])
	}
}
