package com.hypermodel.games.engine.jvmmodel

import android.os.Bundle
import com.badlogic.gdx.ApplicationListener
import com.badlogic.gdx.Game
import com.badlogic.gdx.Screen
import com.badlogic.gdx.audio.Music
import com.badlogic.gdx.backends.android.AndroidApplication
import com.badlogic.gdx.backends.gwt.GwtApplication
import com.badlogic.gdx.backends.gwt.GwtApplicationConfiguration
import com.badlogic.gdx.backends.iosrobovm.IOSApplication
import com.badlogic.gdx.graphics.OrthographicCamera
import com.badlogic.gdx.graphics.g2d.SpriteBatch
import com.badlogic.gdx.graphics.g2d.TextureAtlas
import com.badlogic.gdx.maps.tiled.TiledMap
import com.badlogic.gdx.maps.tiled.TmxMapLoader
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer
import com.badlogic.gdx.physics.box2d.Box2DDebugRenderer
import com.badlogic.gdx.physics.box2d.World
import com.badlogic.gdx.scenes.scene2d.Stage
import com.badlogic.gdx.scenes.scene2d.ui.Label
import com.badlogic.gdx.utils.Disposable
import com.badlogic.gdx.utils.viewport.Viewport
import com.google.gwt.event.logical.shared.ResizeEvent
import com.google.gwt.event.logical.shared.ResizeHandler
import com.hypermodel.games.engine.gameDSL.GamePackage
import com.hypermodel.games.engine.gameDSL.GameRoot
import com.hypermodel.games.engine.gameDSL.GameScene
import com.hypermodel.games.engine.gameDSL.GameScreen
import com.hypermodel.games.engine.generator.GameProperties
import com.hypermodel.games.engine.generator.GameProperties.ProjectType
import javax.inject.Inject
import org.eclipse.xtext.common.types.JvmField
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.moe.natj.general.Pointer
import com.hypermodel.games.engine.gameDSL.GameDisplayValueType
import com.badlogic.gdx.utils.viewport.FitViewport
import com.badlogic.gdx.scenes.scene2d.ui.Table
import com.badlogic.gdx.graphics.g2d.BitmapFont
import com.badlogic.gdx.graphics.Color
import com.badlogic.gdx.math.Vector2
import com.hypermodel.games.engine.gameDSL.GameSprite
import com.badlogic.gdx.graphics.g2d.Sprite
import com.badlogic.gdx.physics.box2d.Body
import com.badlogic.gdx.graphics.g2d.Animation
import com.badlogic.gdx.graphics.g2d.TextureRegion
import com.badlogic.gdx.utils.Array
import com.badlogic.gdx.physics.box2d.BodyDef
import com.badlogic.gdx.physics.box2d.FixtureDef
import com.badlogic.gdx.physics.box2d.CircleShape
import com.badlogic.gdx.physics.box2d.EdgeShape
import java.util.HashMap
import com.badlogic.gdx.physics.box2d.PolygonShape
import org.eclipse.xtext.common.types.JvmDeclaredType

class GameDSLJvmModelInferrer extends AbstractModelInferrer {
	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	val genInfo = "generated by hypermodels.com"

	def dispatch void infer(GamePackage gamePkg, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		gamePkg.games.forEach[game|
			// core module
			val rootClass = gamePkg.toClass(game.fullyQualifiedName) 
			acceptor.accept(
				rootClass,
				[
					superTypes += Game.typeRef
					packageName = game.fullyQualifiedName.skipLast(1).toString
					documentation = genInfo
					it.toFields(game)
					it.toOperations(gamePkg, game)
				]
			)
			// launchers
			ProjectType.values.filter[it != ProjectType.core].forEach[acceptor.createLauncher(gamePkg, game, it)]
			// scenes
			game.scenes.forEach[acceptor.createScene(gamePkg, rootClass, it)]
			// screens
			game.screens.forEach[acceptor.createScreen(gamePkg, rootClass, it)]
		]
	}

	protected def void createLauncher(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, GameRoot game, ProjectType pType) {
		val doc = genInfo
		switch (pType) {
			case ProjectType.android: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				launcherClass.superTypes.add(AndroidApplication.typeRef)
				acceptor.accept(
					launcherClass,
					[
						var method = game.toMethod("onCreate", Void.TYPE.typeRef, [
							parameters += game.toParameter("savedInstanceState", Bundle.typeRef)
							annotations += Override.annotationRef
							body = [
								append(
								'''
								super.onCreate(savedInstanceState);
								AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
								«IF gamePkg.config.android.useAccelerometer»config.useAccelerometer = true;«ENDIF»
								initialize(new «game.name.toFirstUpper»(), config);''')
							]
						])
						it.members += method
						packageName = gamePkg.fullyQualifiedName.toString
						documentation = doc
					]
				)
			}
			case ProjectType.desktop: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				acceptor.accept(
					launcherClass,
					[
						var method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
								new LwjglApplication(new «game.fullyQualifiedName»(), config);''')
							]
						])
						method.static = true
						it.members += method
						packageName = '''«gamePkg.fullyQualifiedName.toString».«pType.name»'''
						documentation = doc
					]
				)
			}
			case ProjectType.html: {
				val launcherClass = gamePkg.toClass('''«pType.name.toFirstUpper»Launcher''');
				launcherClass.superTypes.add(GwtApplication.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = '''«gamePkg.fullyQualifiedName.toString».client'''
						documentation = doc
						var field = game.toField("PADDING", int.typeRef, [
							initializer = [append('''0''')]
						])
						it.members += field
						field = game.toField("cfg", GwtApplicationConfiguration.typeRef)
						it.members += field
						var method = game.toMethod("getConfig", GwtApplicationConfiguration.typeRef, [
								annotations += Override.annotationRef
								body = [
									append(
								'''
									int w = Window.getClientWidth() - PADDING;
									int h = Window.getClientHeight() - PADDING;
									cfg = new GwtApplicationConfiguration(w, h);
									Window.enableScrolling(false);
									Window.setMargin("0");
									Window.addResizeHandler(new ResizeListener());
									cfg.preferFlash = false;
									return cfg;''')
								]
							])
						it.members += method
						method = game.toMethod("createApplicationListener", ApplicationListener.typeRef, [
								annotations += Override.annotationRef
								body = [
									append(
								'''
									return new «game.fullyQualifiedName»();''')
								]
							])
						it.members += method
						val resizeClass = gamePkg.toClass("ResizeListener");
						resizeClass.superTypes.add(ResizeHandler.typeRef)
						var innermethod = game.toMethod("onResize", Void.TYPE.typeRef, [
							parameters += game.toParameter("event", ResizeEvent.typeRef)
							annotations += Override.annotationRef
							body = [
								append(
								'''
								int width = event.getWidth() - PADDING;
								int height = event.getHeight() - PADDING;
								getRootPanel().setWidth("" + width + "px");
								getRootPanel().setHeight("" + height + "px");
								getApplicationListener().resize(width, height);
								Gdx.graphics.setWindowedMode(width, height);''')
							]
						])
						resizeClass.members += innermethod
						it.members += resizeClass
					]
				)
			}
			case ProjectType.ios: {
				val launcherClass = gamePkg.toClass('''«pType.name.toUpperCase»Launcher''');
				launcherClass.superTypes.add(IOSApplication.Delegate.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = '''«gamePkg.fullyQualifiedName.toString»'''
						documentation = doc
						var method = game.toMethod("createApplication", IOSApplication.typeRef, [
							annotations += Override.annotationRef
							body = [
								append(
								'''
								IOSApplicationConfiguration config = new IOSApplicationConfiguration();
								«IF gamePkg.config.ios.useAccelerometer»config.useAccelerometer = true;«ENDIF»
								return new IOSApplication(new «game.name.toFirstUpper»(), config);''')
							]
						])
						it.members += method
						method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								NSAutoreleasePool pool = new NSAutoreleasePool();
								UIApplication.main(arg, null, «pType.name.toUpperCase»«GameProperties.launcherPostfix».class);
								pool.close();''')
							]
						])
						method.static = true
						it.members += method
					]
				)
			}
			case ProjectType.iosmoe: {
				val launcherClass = gamePkg.toClass('''«pType.name.toUpperCase»Launcher''');
				launcherClass.superTypes.add(com.badlogic.gdx.backends.iosmoe.IOSApplication.Delegate.typeRef)
				acceptor.accept(
					launcherClass,
					[
						packageName = gamePkg.fullyQualifiedName.toString
						documentation = doc
						var constructor = game.toConstructor( [
							parameters += game.toParameter("peer", Pointer.typeRef)
							body = [
								append(
								'''
								super(peer);''')
							]
						])
						constructor.visibility = JvmVisibility.PROTECTED
						it.members += constructor
						var method = game.toMethod("createApplication",	com.badlogic.gdx.backends.iosmoe.IOSApplication.typeRef, [
								annotations += Override.annotationRef
								body = [
									append(
								'''
									IOSApplicationConfiguration config = new IOSApplicationConfiguration();
									«IF gamePkg.config.iosmoe.useAccelerometer»config.useAccelerometer = true;«ENDIF»
									return new IOSApplication(new «game.name.toFirstUpper»(), config);''')
								]
							])
						it.members += method
						method = game.toMethod("main", Void.TYPE.typeRef, [
							parameters += game.toParameter("arg", typeof(String[]).typeRef)
							body = [
								append(
								'''
								UIKit.UIApplicationMain(0, null, null, «pType.name.toUpperCase»«GameProperties.launcherPostfix».class.getName());''')
							]
						])
						method.static = true
						it.members += method
					]
				)
			}
			default: {
			}
		}
	}

	def void toFields(JvmGenericType type, GameRoot game) {
		var JvmField field = null
		field = game.toField("batch", SpriteBatch.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("V_WIDTH", int.typeRef)[initializer = [append('''«game.width»''')]]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("V_HEIGHT", int.typeRef) [initializer = [append('''«game.height»''')]]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("TITLE", String.typeRef) [
			initializer = [append('''"«game.title»"''')]
		]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = game.toField("PPM", float.typeRef)[initializer = [append('''«game.ppm»f''')]]
		field.static = true
		field.final = true
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
	}

	def void toOperations(JvmGenericType type, GamePackage gamePkg, GameRoot game) {
		type.members += game.toMethod("create", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				it.append(
				'''
				batch = new SpriteBatch();
				''')
				for (screen : game.screens) {
					it.append("setScreen(new ")
					it.append(gamePkg.toClass(screen.fullyQualifiedName))
					it.append("(this));")
				}
			]
		])

		type.members += game.toMethod("render", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				super.render();''')
			]
		])
		type.members += game.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				super.dispose();
				batch.dispose();''')
			]
		])
	}

	// screens
	def void createScreen(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, GameScreen screen) {
		val screenClass = gamePkg.toClass(screen.fullyQualifiedName) 
		acceptor.accept(
			screenClass,
			[
				superTypes += Screen.typeRef
				packageName = screen.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toFields(gamePkg, screen, gameClass)
				members += screen.toConstructor [
					parameters += gamePkg.toParameter("game", gameClass.typeRef)
					body = [
						append(
						'''
						this.game = game;
						atlas = new TextureAtlas("«screen.atlasName».pack");
						gamecam = new OrthographicCamera();
						gamePort = new ''')
						append(FitViewport)
						append(
						'''
						(MarioBros.V_WIDTH / MarioBros.PPM, MarioBros.V_HEIGHT / MarioBros.PPM, gamecam);
						mapLoader = new TmxMapLoader();
						map = mapLoader.load("level1.tmx");
						renderer = new OrthogonalTiledMapRenderer(map, 1 / MarioBros.PPM);
						gamecam.position.set(gamePort.getWorldWidth() / 2, gamePort.getWorldHeight() / 2, 0);
						world = new World(new ''')
						append(Vector2)
						append(
						'''
						(0, -10), true);
						b2dr = new Box2DDebugRenderer();
						«IF screen.scene !== null»«screen.scene.name.toFirstLower» = new «screen.scene.name.toFirstUpper»(game.batch);«ENDIF»
						''')
						
					]
				]
				it.toOperations(screen)
			]
		)
		// sprites
		screen.sprites.forEach[acceptor.createSprite(gamePkg, gameClass, screenClass, it)]
	}

	def void toFields(JvmGenericType type, GamePackage gamePkg, GameScreen screen, JvmGenericType gameClass) {
		var JvmField field = null
		type.members += screen.toField("game", gameClass.typeRef)
		type.members += screen.toField("atlas", TextureAtlas.typeRef)
		type.members += screen.toField("gamecam", OrthographicCamera.typeRef);
		type.members += screen.toField("gamePort", Viewport.typeRef);
		type.members += screen.toField("mapLoader", TmxMapLoader.typeRef);
		type.members += screen.toField("map", TiledMap.typeRef);
		type.members += screen.toField("renderer", OrthogonalTiledMapRenderer.typeRef);
		type.members += screen.toField("world", World.typeRef);
		type.members += screen.toField("b2dr", Box2DDebugRenderer.typeRef);
		type.members += screen.toField("music", Music.typeRef);
//		type.members += screen.toField("creator", B2WorldCreator.typeRef);
//		type.members += screen.toField("player", Mario.typeRef);
//		type.members += screen.toField("items", Array, Item.typeRef)) ;
//		type.members += screen.toField("itemsToSpawn", LinkedBlockingQueue, ItemDef.typeRef)) ;
		if(screen.scene !== null) {
			field = screen.toField(screen.scene.name.toFirstLower, gamePkg.toClass(screen.scene.fullyQualifiedName).typeRef)
			field.visibility = JvmVisibility.PUBLIC 
			type.members += field
		}
	}

	def void toOperations(JvmGenericType type, GameScreen screen) {
		type.members += screen.toGetter("atlas", TextureAtlas.typeRef)
		type.members += screen.toGetter("map", TiledMap.typeRef)
		type.members += screen.toGetter("world", World.typeRef)
		type.members += screen.toMethod("resize", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			parameters += screen.toParameter("width", int.typeRef)
			parameters += screen.toParameter("height", int.typeRef)
			body = [
				append(
				'''
				gamePort.update(width, height);''')
			]
		])
		type.members += screen.toMethod("pause", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("resume", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				map.dispose();
				renderer.dispose();
				world.dispose();
				b2dr.dispose();
				«IF screen.scene !== null»«screen.scene.name.toFirstLower».dispose();«ENDIF»
				''')
			]
		])
		type.members += screen.toMethod("show", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("render", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			parameters += screen.toParameter("delta", float.typeRef)
			body = [
				append(
				'''
				''')
			]
		])
		type.members += screen.toMethod("hide", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				''')
			]
		])
	}

	// scenes
	def void createScene(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, GameScene scene) {
		acceptor.accept(
			gamePkg.toClass(scene.fullyQualifiedName),
			[
				superTypes += Disposable.typeRef
				packageName = scene.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toFields(scene, gameClass)
				members += scene.toConstructor [
					parameters += gamePkg.toParameter("spriteBatch", SpriteBatch.typeRef)
					body = [
						append("viewport = new ")
						append(FitViewport)
						append("(")
						append(gamePkg.toClass(gameClass.fullyQualifiedName))
						append('''.V_WIDTH, «gameClass.simpleName».V_HEIGHT, new ''')
						append(OrthographicCamera)
						append("());\n")
						append("stage = new ")
						append(Stage)
						append("(viewport, spriteBatch);\n")
						append(Table)
						append(
						'''
						 table = new Table();
						table.top();
						table.setFillParent(true);
						stage.addActor(table);
						''')
						val current = it
						if(scene.hasScore) {
							scene.score.displays.forEach[
								current.append(
								'''
								«it.name»TitleLabel = new Label("«it.name.toUpperCase»", new Label.LabelStyle(new ''')
								current.append(BitmapFont)
								current.append("(), ")
								current.append(Color)
								current.append(".WHITE));\n")
								current.append(
								'''
								table.add(«it.name»TitleLabel).expandX().padTop(«scene.score.topPadding»);
								''')
							]
							it.append("table.row();\n")
							scene.score.displays.forEach[
								current.append(
								'''
								«it.name»ValueLabel = new Label(String.format("«it.format»", «it.name»), new Label.LabelStyle(new BitmapFont(), Color.WHITE));
								table.add(«it.name»ValueLabel).expandX();
								''')
							]
						}
					]
				]
				it.toOperations(scene)
			]
		)
	}

	def void toFields(JvmGenericType type, GameScene scene, JvmGenericType gameClass) {
		var field = scene.toField("stage", Stage.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		type.members += scene.toField("viewport", Viewport.typeRef)
		if(scene.hasScore) {
			scene.score.displays.forEach[
				type.members += scene.toField('''«it.name»TimeCount''', float.typeRef) [initializer = [append("0")]]
				var displayField = scene.toField('''«it.name»''', it.type.getName.typeRef)
				val current = it			
				displayField.initializer = [append('''«IF current.hasInitial»«IF current.type == GameDisplayValueType.STRING»"«current.initialStringValue»"«ELSEIF current.type == GameDisplayValueType.FLOAT»«current.initialNumberValue»«ELSEIF current.type == GameDisplayValueType.INT»«current.initialIntValue»«ENDIF»«ELSE»«IF current.type == GameDisplayValueType.STRING»""«ELSEIF current.type == GameDisplayValueType.FLOAT»0.0«ELSEIF current.type == GameDisplayValueType.INT»0«ENDIF»«ENDIF»''')]
				if(it.hasAdder||it.hasSetter) {
					displayField.static = true
				}
				type.members += displayField
				type.members += scene.toField('''«it.name»TitleLabel''', Label.typeRef)
				type.members += scene.toField('''«it.name»ValueLabel''', Label.typeRef)
			]
		}
	}

	def void toOperations(JvmGenericType type, GameScene scene) {
		type.members += scene.toMethod("update", Void.TYPE.typeRef, [
			parameters += scene.toParameter("dt", float.typeRef)
			body = [
				val current = it
				if(scene.hasScore) {
					scene.score.displays.filter[it.hasDelta].forEach[
						current.append(
						'''
						«it.name»TimeCount += dt;
						if («it.name»TimeCount >= «it.timePeriod») {
							«it.name» += «it.deltaValue»;
							«it.name»ValueLabel.setText(String.format("«it.format»", «it.name»));
							«it.name»TimeCount = 0;
						}
						''')
					]
				}
			]
		])
		type.members += scene.toMethod("dispose", Void.TYPE.typeRef, [
			annotations += Override.annotationRef
			body = [
				append(
				'''
				stage.dispose();
				''')
			]
		])
		if(scene.hasScore) {
			scene.score.displays.filter[it.hasAdder].forEach[
				val current = it
				var operation = scene.toMethod('''add«it.name.toFirstUpper»''', Void.TYPE.typeRef, [
					parameters += scene.toParameter("value", current.type.getName.typeRef)
					body = [
						append(
						'''
						«current.name» += value;
						''')
					]
				])
				operation.static = true
				type.members += operation 
			]
			scene.score.displays.filter[it.hasSetter].forEach[
				val current = it
				var operation = scene.toMethod('''set«it.name.toFirstUpper»''', Void.TYPE.typeRef, [
					parameters += scene.toParameter("value", current.type.getName.typeRef)
					body = [
						append(
						'''
						«current.name» = value;
						''')
					]
				])
				operation.static = true
				type.members += operation 
			]
		}
	}

	// sprites
	def void createSprite(IJvmDeclaredTypeAcceptor acceptor, GamePackage gamePkg, JvmGenericType gameClass, JvmGenericType screenClass, GameSprite sprite) {
		acceptor.accept(
			gamePkg.toClass(sprite.fullyQualifiedName),
			[
				superTypes += Sprite.typeRef
				packageName = sprite.fullyQualifiedName.skipLast(1).toString
				documentation = genInfo
				it.toFields(sprite)
				members += sprite.toConstructor [
					parameters += gamePkg.toParameter("screen", screenClass.typeRef)
					if(!sprite.hasStartPosition) {
						parameters += gamePkg.toParameter("x", int.typeRef)
						parameters += gamePkg.toParameter("y", int.typeRef)
					}
					body = [
						append(
						'''
						world = screen.getWorld();
						stateTimer = 0;
						int xPosition = «IF sprite.hasStartPosition»«sprite.x»«ELSE»x«ENDIF»;
						int yPosition = «IF sprite.hasStartPosition»«sprite.y»«ELSE»y«ENDIF»;
						''')
						append(Array)
						append("<")
						append(TextureRegion)
						append("> frames = new Array<TextureRegion>();\n")
						val current = it
						sprite.states.forEach[
							if(it.animation !== null) {
								if(it.animation.hasFrames) {
									current.append(
									'''
									for (int i = «it.animation.offset»; i < «it.animation.frames+it.animation.offset»; i++) {
										TextureRegion «it.animation.name»TextureRegion = new TextureRegion(screen.getAtlas().findRegion("«it.animation.region.region»"), i * «it.animation.region.width», 0, «it.animation.region.width», «it.animation.region.height»);
										«it.animation.name»TextureRegion.flip(«it.animation.region.flipX.booleanValue», «it.animation.region.flipY.booleanValue»); 
										frames.add(«it.animation.name»TextureRegion);
									}
									''')
								}
								if(it.animation.hasStands) {
									it.animation.stands.forEach[
										current.append(
										'''
										TextureRegion «it.name»TextureRegion = new TextureRegion(screen.getAtlas().findRegion("«it.region.name»"), «it.offset*it.region.width», 0, «it.region.width», «it.region.height»);
										«it.name»TextureRegion.flip(«it.region.flipX.booleanValue», «it.region.flipY.booleanValue»); 
										frames.add(«it.name»TextureRegion);
										''')
									]
									
								}
								current.append(
								'''
								«it.animation.name» = new ''')
								current.append(Animation)
								current.append('''
								<TextureRegion>(«it.animation.duration»f, frames);
								frames.clear();
								''')
							}
							if(it.stand !== null) {
								current.append(
									'''
									«it.stand.name» = new TextureRegion(screen.getAtlas().findRegion("«it.stand.region.name»"), «it.stand.offset*it.stand.region.width», 0, «it.stand.region.width», «it.stand.region.height»);
									«it.stand.name».flip(«it.stand.region.flipX.booleanValue», «it.stand.region.flipY.booleanValue»); 
									'''
								)
							}
						]
						append(
						'''
				        define«sprite.name.toFirstUpper»(new Vector2(xPosition / ''')
				        append(gameClass)
				        append('''.PPM, yPosition / «gameClass.simpleName».PPM));
				        ''')
						append("setRegion(getFrame(0.0f));\n");
					]
				]
				it.toOperations(sprite, gameClass)
			]
		)
	}

	def void toFields(JvmGenericType type, GameSprite sprite) {
		var field = sprite.toField("world", World.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		field = sprite.toField("body", Body.typeRef)
		field.visibility = JvmVisibility.PUBLIC
		type.members += field
		type.members += sprite.toField("stateTimer", float.typeRef)
		var stateType = sprite.toEnumerationType("State") [
			sprite.states.forEach [ state |
				members += state.toEnumerationLiteral(state.name.toUpperCase)
				if(state.animation !== null) {
					type.members += sprite.toField(state.animation.name, Animation.typeRef(TextureRegion.typeRef))
				}
				if(state.stand !== null) {
					type.members += sprite.toField(state.stand.name, TextureRegion.typeRef)
				}
			]
		]
		var JvmDeclaredType dt = stateType
		type.members += stateType
		type.members += sprite.toField("currentState", typeRef(dt)) [initializer=[append('''State.«sprite.initialState.name.toUpperCase»''')]]
		type.members += sprite.toField("previousState", typeRef(dt)) [initializer=[append('''State.«sprite.initialState.name.toUpperCase»''')]]
		type.members += sprite.toField("positionOffsetX", float.typeRef) [initializer=[append('''0.0f''')]]
		type.members += sprite.toField("positionOffsetY", float.typeRef) [initializer=[append('''0.0f''')]]
		if(sprite.hasVelocity) {
			type.members += sprite.toField("velocity", Vector2.typeRef) [initializer=[append('''new Vector2(«sprite.velocity.x»,«sprite.velocity.y»)''')]]
		}
		val fsprite = sprite
		sprite.properties.forEach[
			type.members += fsprite.toField('''«it.name»''', Boolean.typeRef)  [initializer=[append('''false''')]]
		]
	}

	def void toOperations(JvmGenericType type, GameSprite sprite, JvmGenericType gameClass) {
		val i = 0 as int
		for(state: sprite.states) {
			type.members += sprite.toMethod('''is«state.rule.name.toFirstUpper»''', boolean.typeRef) [
				documentation = state.rule.documentation
				for (p : state.rule.params) {
					parameters += p.toParameter(p.name, p.parameterType)
				}
				body = state.rule.body
			]
		}
		val fsprite = sprite
		sprite.properties.forEach[
			val prop = it
			type.members += fsprite.toMethod('''is«it.name.toFirstUpper»''', Boolean.typeRef, [
				body = [
					append(
					'''
					return «prop.name»;
					''')
				]
			])
		]
		sprite.properties.forEach[
			val prop = it
			type.members += fsprite.toMethod('''set«it.name.toFirstUpper»''', Void.TYPE.typeRef, [
				parameters += sprite.toParameter("value", Boolean.typeRef)
				body = [
					append(
					'''
					«prop.name» = value;
					''')
				]
			])
		]
		
		sprite.properties.filter[it.onUpdate].forEach[
			val prop = it
			type.members += sprite.toMethod('''do«it.name.toFirstUpper»''', Void.TYPE.typeRef) [
				documentation = prop.documentation
				body = prop.body
			]
		]

		type.members += sprite.toMethod("update", Void.TYPE.typeRef, [
			parameters += sprite.toParameter("dt", float.typeRef)
			body = [
				append(
				'''
				setPosition(body.getPosition().x - getWidth() / 2, body.getPosition().y - getHeight() / 2);
				''')
				val current = it
				sprite.properties.filter[it.onUpdate].forEach[
					current.append(
					'''
					if(«it.name») {
						do«it.name.toFirstUpper»();
					}
					''')
				]
				append(
				'''
				setRegion(getFrame(dt));
				''')
			]
		])
		type.members += sprite.toMethod("getFrame", TextureRegion.typeRef, [
			parameters += sprite.toParameter("dt", float.typeRef)
			body = [
				append(
				'''
		        currentState = getState();
		        TextureRegion region = null;
		        switch (currentState) {
		        ''')
		        val current = it
				sprite.states.forEach[
					current.append(
					'''
					case «it.name.toUpperCase»:
						region = «IF it.animation!==null»«it.animation.name».getKeyFrame(stateTimer)«ELSEIF it.stand!==null»«it.stand.name»«ENDIF»;
						«IF it.animation!==null && it.ifFinished»if(«it.animation.name».isAnimationFinished(stateTimer)) {
							set«setFalse.name.toFirstUpper»(false);
						}«ENDIF»
						positionOffsetX = «IF it.animation!==null»«IF it.animation.hasFrames»«it.animation.region.offsetX»f«ELSEIF it.animation.hasStands»«it.animation.stands.get(0).region.offsetX»f«ENDIF»«ELSEIF it.stand!==null»«it.stand.region.offsetX»f«ENDIF»;
						positionOffsetY = «IF it.animation!==null»«IF it.animation.hasFrames»«it.animation.region.offsetY»f«ELSEIF it.animation.hasStands»«it.animation.stands.get(0).region.offsetY»f«ENDIF»«ELSEIF it.stand!==null»«it.stand.region.offsetY»f«ENDIF»;
						break;
					''')
				]		        	
				append(
				'''
		        }
		        stateTimer = currentState == previousState ? stateTimer + dt : 0;
		        previousState = currentState;
		        return region;
				''')
			]
		])
		type.members += sprite.toMethod("getState", "State".typeRef, [
			body = [
				for(state: sprite.states) {
					append(
					'''
					if(is«state.rule.name.toFirstUpper»()) {
						return State.«state.name.toUpperCase»;
					}
					''')
				}
				append(
				'''
				return State.«sprite.initialState.name.toUpperCase»;
				''')
			]
		])
		type.members += sprite.toMethod('''redefine«sprite.name.toFirstUpper»''', Void.TYPE.typeRef, [
			body = [
				append(
				'''
				Vector2 position = body.getPosition();
				world.destroyBody(body);
				position.add(positionOffsetX / «gameClass.simpleName».PPM, positionOffsetY / «gameClass.simpleName».PPM); 
				define«sprite.name.toFirstUpper»(position);
				''')
			]
		])
		type.members += sprite.toMethod('''define«sprite.name.toFirstUpper»''', Void.TYPE.typeRef, [
			parameters += sprite.toParameter("position", Vector2.typeRef)
			body = [
				append(BodyDef)
				append('''
				 bdef = new BodyDef();
				bdef.position.set(position);
				bdef.type = BodyDef.BodyType.DynamicBody;
				body = world.createBody(bdef);
				''')
				append(FixtureDef)
				append(''' fdef = new FixtureDef();
				''')
				append(CircleShape)
				append('''
				 shape = new CircleShape();
				shape.setRadius(«sprite.radius» / «gameClass.simpleName».PPM);
				fdef.filter.categoryBits = «(2**sprite.id) as int»;
				''')
				var mask = 0.0
				for(s:sprite.interactionSprites) {
					mask = mask + (2**s.id)
				}
				append('''
				fdef.filter.maskBits = «mask as int»;
				fdef.shape = shape;
				shape.setPosition(new Vector2(-positionOffsetX / «gameClass.simpleName».PPM, -positionOffsetY / «gameClass.simpleName».PPM));
				body.createFixture(fdef).setUserData(this);
				''')
				if(sprite.hasSensor) {
					if(sprite.vectors2d.length==2) {
						append(EdgeShape)
					} else {
						append(PolygonShape)
					}
					append(
					''' head = new «IF sprite.vectors2d.length==2»Edge«ELSE»Polygon«ENDIF»Shape();
					''')
					if(sprite.vectors2d.length==2) {
						append(
						'''
						head.set(new Vector2(«sprite.vectors2d.get(0).x» / 2 / «gameClass.simpleName».PPM, «sprite.radius» / «gameClass.simpleName».PPM), new Vector2(«sprite.vectors2d.get(0).y» / 2 / «gameClass.simpleName».PPM, «sprite.radius» / «gameClass.simpleName».PPM));
						''')
					} else {
						append(
						'''
						Vector2[] vertice = new Vector2[«sprite.vectors2d.length»];
						''')
						for(var idx=0;idx<sprite.vectors2d.length;idx++) {
							append(
							'''
							vertice[«idx»] = new Vector2(«sprite.vectors2d.get(idx).x», «sprite.vectors2d.get(idx).y»).scl(1 / «gameClass.simpleName».PPM);
							''')
						}
					}
					append(
					'''
					fdef.filter.categoryBits = «(2**sprite.sensorID) as int»;
					fdef.shape = head;
					fdef.isSensor = true;
					body.createFixture(fdef).setUserData(this);
					''')
				}
		        if(sprite.initialState.animation !== null) {
		        	if(sprite.initialState.animation.hasFrames) {
			        	append(
			        	'''
			        	setBounds(position.x, position.y, «sprite.initialState.animation.region.width» / «gameClass.simpleName».PPM, «sprite.initialState.animation.region.height» / «gameClass.simpleName».PPM);
			        	''')
			        }
		        	if(sprite.initialState.animation.hasStands) {
			        	append(
			        	'''
			        	setBounds(position.x, position.y, «sprite.initialState.animation.stands.get(0).region.width» / «gameClass.simpleName».PPM, «sprite.initialState.animation.stands.get(0).region.height» / «gameClass.simpleName».PPM);
			        	''')
			        }
		        }
		        if(sprite.initialState.stand !== null) {
		        	append(
		        	'''
		        	setBounds(position.x, position.y, «sprite.initialState.stand.region.width» / «gameClass.simpleName».PPM, «sprite.initialState.stand.region.height» / «gameClass.simpleName».PPM);
		        	''')
		        }
			]
		])
		sprite.events.forEach[
			val event = it
			type.members += sprite.toMethod('''«it.name»''', Void.TYPE.typeRef, [
				documentation = it.documentation
				for (p : event.params) {
					parameters += p.toParameter(p.name, p.parameterType)
				}
				body = event.body
			])		
		]
	}
}
