package com.hypermodel.games.engine.jvmmodel;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.backends.android.AndroidApplication;
import com.hypermodel.games.engine.gameDSL.Game;
import com.hypermodel.games.engine.gameDSL.GamePackage;
import java.util.Arrays;
import java.util.regex.Pattern;
import javax.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.common.types.JvmAnnotationReference;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.xbase.compiler.output.ITreeAppendable;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.StringExtensions;

@SuppressWarnings("all")
public class GameDSLJvmModelInferrer extends AbstractModelInferrer {
  @Inject
  @Extension
  private JvmTypesBuilder _jvmTypesBuilder;
  
  @Inject
  @Extension
  private IQualifiedNameProvider _iQualifiedNameProvider;
  
  protected void _infer(final GamePackage gamePkg, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    EList<Game> _games = gamePkg.getGames();
    for (final Game game : _games) {
      {
        String rootClassName = StringExtensions.toFirstUpper(this.className(game));
        final JvmGenericType rootClass = this._jvmTypesBuilder.toClass(gamePkg, rootClassName);
        rootClass.getSuperTypes().add(this._typeReferenceBuilder.typeRef(ApplicationAdapter.class));
        rootClass.setSimpleName(StringExtensions.toFirstUpper(rootClass.getSimpleName()));
        final String pkgName = this._iQualifiedNameProvider.getFullyQualifiedName(gamePkg).toString();
        final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
          this.toFields(it, game);
          this.toOperations(it, game);
          it.setPackageName(pkgName);
          this._jvmTypesBuilder.setDocumentation(it, "generated by hypermodels.com");
        };
        acceptor.<JvmGenericType>accept(rootClass, _function);
        final JvmGenericType launcherClass = this._jvmTypesBuilder.toClass(gamePkg, "AndroidLauncher");
        launcherClass.getSuperTypes().add(this._typeReferenceBuilder.typeRef(AndroidApplication.class));
        launcherClass.setSimpleName(StringExtensions.toFirstUpper(launcherClass.getSimpleName()));
        final Procedure1<JvmGenericType> _function_1 = (JvmGenericType it) -> {
          EList<JvmMember> _members = it.getMembers();
          final Procedure1<JvmOperation> _function_2 = (JvmOperation it_1) -> {
            EList<JvmFormalParameter> _parameters = it_1.getParameters();
            JvmFormalParameter _parameter = this._jvmTypesBuilder.toParameter(game, "savedInstanceState", this._typeReferenceBuilder.typeRef("android.os.Bundle"));
            this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, _parameter);
            EList<JvmAnnotationReference> _annotations = it_1.getAnnotations();
            JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
            this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
            final Procedure1<ITreeAppendable> _function_3 = (ITreeAppendable it_2) -> {
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("super.onCreate(savedInstanceState);");
              _builder.newLine();
              _builder.append("AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();");
              _builder.newLine();
              {
                boolean _isUseAccelerometer = gamePkg.getConfig().getAndroid().isUseAccelerometer();
                if (_isUseAccelerometer) {
                  _builder.append("config.useAccelerometer = true;");
                }
              }
              _builder.newLineIfNotEmpty();
              _builder.append("initialize(new ");
              String _name = game.getName();
              _builder.append(_name);
              _builder.append("(), config);");
              it_2.append(_builder);
            };
            this._jvmTypesBuilder.setBody(it_1, _function_3);
          };
          JvmOperation _method = this._jvmTypesBuilder.toMethod(game, "onCreate", this._typeReferenceBuilder.typeRef(Void.TYPE), _function_2);
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members, _method);
          it.setPackageName(pkgName);
          this._jvmTypesBuilder.setDocumentation(it, "generated by hypermodels.com");
        };
        acceptor.<JvmGenericType>accept(launcherClass, _function_1);
      }
    }
  }
  
  public void toFields(final JvmGenericType type, final Game game) {
    JvmField field = null;
    field = this._jvmTypesBuilder.toField(game, "batch", this._typeReferenceBuilder.typeRef("SpriteBatch"));
    EList<JvmMember> _members = type.getMembers();
    this._jvmTypesBuilder.<JvmField>operator_add(_members, field);
    field = this._jvmTypesBuilder.toField(game, "img", this._typeReferenceBuilder.typeRef("Texture"));
    EList<JvmMember> _members_1 = type.getMembers();
    this._jvmTypesBuilder.<JvmField>operator_add(_members_1, field);
  }
  
  public void toOperations(final JvmGenericType type, final Game game) {
    EList<JvmMember> _members = type.getMembers();
    final Procedure1<JvmOperation> _function = (JvmOperation it) -> {
      EList<JvmAnnotationReference> _annotations = it.getAnnotations();
      JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
      this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
      final Procedure1<ITreeAppendable> _function_1 = (ITreeAppendable it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("batch = new SpriteBatch();");
        _builder.newLine();
        _builder.append("img = new Texture(\"badlogic.jpg\");");
        it_1.append(_builder);
      };
      this._jvmTypesBuilder.setBody(it, _function_1);
    };
    JvmOperation _method = this._jvmTypesBuilder.toMethod(game, "create", this._typeReferenceBuilder.typeRef(Void.TYPE), _function);
    this._jvmTypesBuilder.<JvmOperation>operator_add(_members, _method);
    EList<JvmMember> _members_1 = type.getMembers();
    final Procedure1<JvmOperation> _function_1 = (JvmOperation it) -> {
      EList<JvmAnnotationReference> _annotations = it.getAnnotations();
      JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
      this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
      final Procedure1<ITreeAppendable> _function_2 = (ITreeAppendable it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Gdx.gl.glClearColor(1, 0, 0, 1);");
        _builder.newLine();
        _builder.append("Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);");
        _builder.newLine();
        _builder.append("batch.begin();");
        _builder.newLine();
        _builder.append("batch.draw(img, 0, 0);");
        _builder.newLine();
        _builder.append("batch.end();");
        it_1.append(_builder);
      };
      this._jvmTypesBuilder.setBody(it, _function_2);
    };
    JvmOperation _method_1 = this._jvmTypesBuilder.toMethod(game, "render", this._typeReferenceBuilder.typeRef(Void.TYPE), _function_1);
    this._jvmTypesBuilder.<JvmOperation>operator_add(_members_1, _method_1);
    EList<JvmMember> _members_2 = type.getMembers();
    final Procedure1<JvmOperation> _function_2 = (JvmOperation it) -> {
      EList<JvmAnnotationReference> _annotations = it.getAnnotations();
      JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
      this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
      final Procedure1<ITreeAppendable> _function_3 = (ITreeAppendable it_1) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("batch.dispose();");
        _builder.newLine();
        _builder.append("img.dispose();");
        it_1.append(_builder);
      };
      this._jvmTypesBuilder.setBody(it, _function_3);
    };
    JvmOperation _method_2 = this._jvmTypesBuilder.toMethod(game, "dispose", this._typeReferenceBuilder.typeRef(Void.TYPE), _function_2);
    this._jvmTypesBuilder.<JvmOperation>operator_add(_members_2, _method_2);
  }
  
  public String className(final Game game) {
    String clsName = StringExtensions.toFirstUpper(game.getName().toString());
    String[] parts = clsName.split(Pattern.quote("."));
    int len = parts.length;
    if ((len > 1)) {
      return StringExtensions.toFirstUpper(parts[(len - 1)]);
    }
    return clsName;
  }
  
  public void infer(final EObject gamePkg, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (gamePkg instanceof GamePackage) {
      _infer((GamePackage)gamePkg, acceptor, isPreIndexingPhase);
      return;
    } else if (gamePkg != null) {
      _infer(gamePkg, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(gamePkg, acceptor, isPreIndexingPhase).toString());
    }
  }
}
