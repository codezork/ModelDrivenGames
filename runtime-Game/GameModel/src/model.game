import com.badlogic.gdx.physics.box2d.Body
import com.badlogic.gdx.math.Vector2
import com.badlogic.gdx.graphics.g2d.Sprite
import com.badlogic.gdx.Gdx

package com.hypermodel.games {
	configuration { 
		android { 
			minAndroidVersion 9
			targetAndroidVersion 25
			SDKApiLevel 19
			orientation landscape 
		}
		ios {     
		}
		iosmoe {   
			useAccelerometer 
		}   
	}
	game MarioBros screenWidth 400 screenHeight 208 title "MarioBros" pixelPerMeter 100  
	timeStep 0.0167 velocityIterations 6 positionIterations 2 worldWidth 240 worldHeight 13
	tileWidth 16 tileHeight 16
	layers {
		layer background index 0 type tile
		layer graphic index 1 type tile
		layer ground index 2 type object
		layer pipes index 3 type object
		layer coins index 4 type object
		layer bricks index 5 type object
		layer goombas index 6 type object
		layer turtles index 7 type object
	}
	regions {
		region marioRunRight name "little_mario" width 16 height 16
		region marioRunLeft name "little_mario" width 16 height 16 flipX
		region marioDead name "little_mario" width 16 height 16   
		region bigMarioRunRight name "big_mario" width 16 height 32 positionOffsetY 8.0  
		region bigMarioRunLeft name "big_mario" width 16 height 32 positionOffsetY 8.0 flipX
		region goomba name "goomba" width 16 height 16
		region mushroom name "mushroom" width 16 height 16
		region turtleLeft name "turtle"  width 16 height 24 positionOffsetY 8.0 
		region turtleRight name "turtle"  width 16 height 24 positionOffsetY 8.0 flipX 
		region turtleStand name "turtle"  width 16 height 24 positionOffsetY 8.0 
	}
	screens {
		screen PlayScreen  
		atlas "Mario_and_Enemies"
		scenes {
			scene Hud topPadding 10
			displays { 
				display mario valueType number format "%06d" initialValue 0 addValue
				display world valueType text format "%s" initialValue "1-1" setValue 
				display time valueType number format "%03d" initialValue 300 deltaTime -1.0 eachTimePeriod 1.0
			}   
			
			scene GameOver topPadding 20 
			messages {
				message gameover text "Game over" row 2
				message click text "click to continue" row 4
			} 
		}
		gameOverScene GameOver
		levels {
			level level1 file "level1.tmx"
		} 
		tiles {
			tile Ground id 0 objectLayer ground
			tile Pipe id 5 objectLayer pipes
			tile Brick id 2 objectLayer bricks tileLayer graphic
			tile Coin id 3 objectLayer coins tileLayer graphic
		}
		sprites {
			sprite Mario id 1 radius 6 
			isPlayer startPosition vector(32.0,15.0) 
			inputs {
				input justPressed up jump 
				input pressed left accelerateLeft
				input pressed right accelerateRight 
			}
			sensor {
		        vector(-3.0,8.0)
				vector(3.0,8.0)  
			} sensorId 9
			actors {
				sprite Mushroom 
				when fixture collidesWith fixture of sprite Goomba do atBeginOfContact hitGoomba
				when fixture collidesWith fixture of sprite Turtle do atBeginOfContact hitTurtle 
				when sensor collidesWith fixture of tile Brick do atBeginOfContact brickHit 
				when sensor collidesWith fixture of tile Coin do atBeginOfContact coinHit
				tile Ground
				tile Pipe 
			} 
			properties {
				property grows
				property big
				property dead
				property timeToDefineBig onUpdateIfTrue { 
					redefineMario();
					timeToDefineBig = false; 
				}   
				property timeToDefineSmall onUpdateIfTrue {
					redefineMario();
					timeToDefineSmall = false; 
				}   
			}
			states { 
				state dead if isTrue playerDead() { 
					return dead 
				} stand marioDead whichFrame 6 from marioDead
				state standSmall if isTrue notMoving() { 
					return body.linearVelocity.y == 0 && body.linearVelocity.x == 0 && !isBig
				} stand marioStand whichFrame 0 from marioRunRight
				state standSmallBig if isTrue notMovingBig() { 
					return body.linearVelocity.y == 0 && body.linearVelocity.x == 0 && isBig
				} stand bigMarioStand whichFrame 0 from bigMarioRunRight
				state runningSmallLeft if isTrue runningLeft() {
					return body.linearVelocity.y == 0 && body.linearVelocity.x < 0 && !isBig
				} animation marioRunleft duration 0.1 frames 4 startFrame 1 from marioRunLeft
				state runningSmallRight if isTrue runningRight() {
					return body.linearVelocity.y == 0 && body.linearVelocity.x > 0 && !isBig
				} animation marioRunRight duration 0.1 frames 4 startFrame 1 from marioRunRight
				state runningBigLeft if isTrue runningBigLeft() {
					return body.linearVelocity.y == 0 && body.linearVelocity.x < 0 && isBig
				} animation bigMarioRunleft duration 0.1 frames 4 startFrame 1 from bigMarioRunLeft 
				state runningBigRight if isTrue runningBigRight() {
					return body.linearVelocity.y == 0 && body.linearVelocity.x > 0 && isBig
				} animation bigMarioRunRight duration 0.1 frames 4 startFrame 1 from bigMarioRunRight
				state jumpSmallLeft if isTrue jumpSmallLeft() {
					return !isDead && !isBig && body.linearVelocity.x < 0 && (body.linearVelocity.y > 0 || body.linearVelocity.y < 0  && previousState.equals(State.JUMPSMALLLEFT)) 
				} stand jumpSmallLeft whichFrame 5 from marioRunLeft
				state jumpSmallRight if isTrue jumpSmallRight() {
					return !isDead && !isBig && body.linearVelocity.x > 0 && (body.linearVelocity.y > 0 || body.linearVelocity.y < 0  && previousState.equals(State.JUMPSMALLRIGHT)) 
				} stand jumpSmallRight whichFrame 5 from marioRunRight 
				state jumpBigLeft if isTrue jumpBigLeft() {
					return !isDead && isBig && body.linearVelocity.x < 0 && (body.linearVelocity.y > 0 || body.linearVelocity.y < 0  && previousState.equals(State.JUMPBIGLEFT))
				} stand jumpBigLeft whichFrame 5 from bigMarioRunLeft 
				state jumpBigRight if isTrue jumpBigRight() {
					return !isDead && isBig && body.linearVelocity.x > 0 && (body.linearVelocity.y > 0 || body.linearVelocity.y < 0  && previousState.equals(State.JUMPBIGRIGHT)) 
				} stand jumpBigRight whichFrame 5 from bigMarioRunRight
				state growing if isTrue doGrowing() { 
					return grows
				} animation marioGrowing duration 0.3 stands {
					stand grow1 whichFrame 15 from bigMarioRunLeft
					stand grow2 whichFrame 0 from bigMarioRunLeft 
					stand grow3 whichFrame 15 from bigMarioRunLeft
					stand grow4 whichFrame 0 from bigMarioRunLeft 
				} ifFinished setFalse grows
			}
			initialState standSmall gameOverState dead
			events {
				event grow() {
					if(!isBig) {
						grows = true
						big = true
						timeToDefineBig = true
						setBounds(getX(), getY(), getWidth(), getHeight() * 2)
					}					
				}
				event hitGoomba(Goomba goomba) {
					if(isBig) {
						big = false
						timeToDefineSmall = true 
						setBounds(getX(), getY(), getWidth(), getHeight() / 2)
					} else {
						die()
					}
				}
				event hitTurtle(Turtle turtle) {
			        if(turtle.currentState.equals(Turtle.State.STANDINGTURTLE)) {
            			if(turtle.position.x > position.x) {
            				turtle.kick(-2.0f)
            			} else {
            				turtle.kick(2.0f)
            			}
            		} else if(isBig) {
						big = false
						timeToDefineSmall = true 
						setBounds(getX(), getY(), getWidth(), getHeight() / 2)
					} else {
						die()
					}
				}
				event brickHit(Brick brick) {
					if(isBig) {
						brick.categoryFilter = 16;
						brick.cell.setTile(null);
						Hud.addMario(200);
					}
				}
				event coinHit(Coin coin) {
					if(coin.cell.^tile.^id != 28 && coin.getProperties().containsKey("mushroom")) {
						creator.spawnItem(new ItemDef(coin.getPositionWithOffset(new Vector2(0.0f, 16.0f)),Mushroom)); 
					}
					coin.cell.^tile = coin.^map.tileSets.getTileSet("tileset_gutter").getTile(28);
            		Hud.addMario(100); 
				}
				event jump() {  
					if(!currentState.equals(State.DEAD) && !currentState.equals(State.JUMPBIGLEFT) && !currentState.equals(State.JUMPBIGRIGHT) && !currentState.equals(State.JUMPSMALLLEFT) && !currentState.equals(State.JUMPSMALLRIGHT)) { 
						body.applyLinearImpulse(new Vector2(0, 4f), body.getWorldCenter(), true)
						currentState = State.JUMPBIGLEFT
					}
				}
				event accelerateRight() {
					if(!currentState.equals(State.DEAD) && body.getLinearVelocity().x <= 1.0) {
						body.applyLinearImpulse(new Vector2(0.1f, 0), body.getWorldCenter(), true)
					}
				}  
				event accelerateLeft() {
					if(!currentState.equals(State.DEAD) && body.getLinearVelocity().x >= -1.0) {
						body.applyLinearImpulse(new Vector2(-0.1f, 0), body.getWorldCenter(), true)
					}
				}
				event die() {
					if(!dead) { 
						dead = true;
						removeMaskBits()
						body.applyLinearImpulse(new Vector2(0, 4f), body.getWorldCenter(), true)	
					}
				}
			}
			
			sprite Goomba id 6 radius 6 isEnemy 
			layer goombas destructible 
			activate if isTrue playerNear(Sprite ^player) {
				return !destroyed && body.position.x < ^player.getX() + 2.24
			}
			velocity vector(-1.0,-2.0) 
			sensor {
				vector(-5.0,8.0)
				vector(5.0,8.0)
				vector(-3.0,3.0)
				vector(3.0,3.0)
			} sensorId 7 
			restitution 0.5
			actors {
				when sensor collidesWith fixture of sprite Mario do atBeginOfContact hitOnHead
				when fixture collidesWith fixture of sprite Goomba do atBeginOfContact hitByGoomba
				when fixture collidesWith fixture of sprite Turtle do atBeginOfContact hitByTurtle
				when fixture collidesWith fixture of tile Pipe do atBeginOfContact collidePipe 
				tile Brick
				tile Coin
				when fixture collidesWith fixture of tile Ground do atBeginOfContact collideGround 
			}
			states {
				state runningGoomba if isTrue notDestroyed () {
					return !destroyed 
				} animation walkAnimation duration 0.4 frames 2 startFrame 0 from goomba
				state destroyingGoomba if isTrue toBeDestroyed () {
					return setToDestroy 
				} stand isdestroyed whichFrame 2 from goomba
			}
			initialState runningGoomba
			events {
				event collidePipe(Pipe pipe) {
					^velocity.x = -^velocity.x
				}
				event hitOnHead(Mario mario) {
					setToDestroy = true 
				}
				event hitByGoomba(Goomba goomba) { 
					^velocity.x = -^velocity.x
				}
				event hitByTurtle(Turtle turtle) { 
					^velocity.x = -^velocity.x
				}
				event collideGround(Ground ground) {
					^velocity.x = -^velocity.x
				}
			}


			sprite Mushroom id 8 radius 6 isItem 
			destructible
			velocity vector(0.7, -0.7)  
			actors {
				when fixture collidesWith fixture of sprite Mario do atBeginOfContact grow
				tile Brick
				tile Coin
				tile Ground
				when fixture collidesWith fixture of tile Pipe do atBeginOfContact reverseVelocityX
			}
			states {
				state standingMushroom if isTrue notDestroyed () {
					return !destroyed 
				} stand isThere whichFrame 0 from mushroom 
			}
			initialState standingMushroom 
			events {
				event grow(Mario mario) {
					setToDestroy = true
					mario.grow()
				}
				event reverseVelocityX(Pipe pipe) {
					^velocity.x = -^velocity.x
				}
			}
			
			
			sprite Turtle id 11 radius 6 isEnemy 
			layer turtles 
			activate if isTrue playerNear(Sprite ^player) {
				return body.position.x < ^player.getX() + 2.24
			}
			velocity vector(-1.0,-2.0)
			sensor {
				vector(-5.0,8.0)
				vector(5.0,8.0)
				vector(-3.0,3.0)
				vector(3.0,3.0)
			} sensorId 12
			restitution 1.8
			actors {
				when sensor collidesWith fixture of sprite Mario do atBeginOfContact hitOnHead
				when fixture collidesWith fixture of sprite Turtle do atBeginOfContact hitByTurtle
				when fixture collidesWith fixture of tile Pipe do atBeginOfContact collidePipe 
				tile Brick
				tile Coin
				sprite Goomba
				when fixture collidesWith fixture of tile Ground do atBeginOfContact collideGround  
			}
			states {
				state walkingTurtleLeft if isTrue isWalkingLeft () {
					return body.linearVelocity.x < 0 && !currentState.equals(State.STANDINGTURTLE) 
				} animation walkAnimationLeft duration 0.2 frames 4 startFrame 0 from turtleLeft
				state walkingTurtleRight if isTrue isWalkingRight () {
					return body.linearVelocity.x > 0 && !currentState.equals(State.STANDINGTURTLE) 
				} animation walkAnimationRight duration 0.2 frames 4 startFrame 0 from turtleRight
				state standingTurtle if isTrue isStanding () {
					if(currentState.equals(State.STANDINGTURTLE) && stateTimer > 5) {
						currentState = State.WALKINGTURTLERIGHT
						^velocity.x = 1
					}
					return currentState.equals(State.STANDINGTURTLE) 
				} stand shell1 whichFrame 4 from turtleStand
				state movingTurtle if isTrue isMoving () {
					return currentState.equals(State.MOVINGTURTLE)
				} stand shell2 whichFrame 4 from turtleStand
			}
			initialState walkingTurtleRight
			events {
				event collidePipe(Pipe pipe) {
					^velocity.x = -^velocity.x
				}
				event collideGround(Ground ground) {
					^velocity.x = -^velocity.x
				}
				event hitOnHead(Mario mario) {
			        if(currentState.equals(State.STANDINGTURTLE)) {
			            if(mario.getPosition().x > getPosition().x)
			                ^velocity.x = -2
			            else
			                ^velocity.x = 2
			            currentState = State.MOVINGTURTLE
			        }
			        else {
			            currentState = State.STANDINGTURTLE
			            ^velocity.x = 0;
			        }
				}
				event hitByTurtle(Turtle turtle) { 
					^velocity.x = -^velocity.x
				}
				event kick(float direction) {
			        ^velocity.x = direction;
			        currentState = State.MOVINGTURTLE
				}
			}
		}
	}
} 
